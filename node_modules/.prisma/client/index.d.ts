
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Candidat
 * 
 */
export type Candidat = $Result.DefaultSelection<Prisma.$CandidatPayload>
/**
 * Model Groupe
 * 
 */
export type Groupe = $Result.DefaultSelection<Prisma.$GroupePayload>
/**
 * Model Examinateur
 * 
 */
export type Examinateur = $Result.DefaultSelection<Prisma.$ExaminateurPayload>
/**
 * Model Terrain
 * 
 */
export type Terrain = $Result.DefaultSelection<Prisma.$TerrainPayload>
/**
 * Model Centre
 * 
 */
export type Centre = $Result.DefaultSelection<Prisma.$CentrePayload>
/**
 * Model Choix
 * 
 */
export type Choix = $Result.DefaultSelection<Prisma.$ChoixPayload>
/**
 * Model Sport
 * 
 */
export type Sport = $Result.DefaultSelection<Prisma.$SportPayload>
/**
 * Model Utilisateur
 * 
 */
export type Utilisateur = $Result.DefaultSelection<Prisma.$UtilisateurPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SEXE: {
  HOMME: 'HOMME',
  FILLE: 'FILLE'
};

export type SEXE = (typeof SEXE)[keyof typeof SEXE]


export const TEMPS: {
  MATIN: 'MATIN',
  APRES_MIDI: 'APRES_MIDI'
};

export type TEMPS = (typeof TEMPS)[keyof typeof TEMPS]


export const TYPE_SPORT: {
  INDIVIDUEL: 'INDIVIDUEL',
  COLLECTIF: 'COLLECTIF',
  COURSE_FOND: 'COURSE_FOND'
};

export type TYPE_SPORT = (typeof TYPE_SPORT)[keyof typeof TYPE_SPORT]

}

export type SEXE = $Enums.SEXE

export const SEXE: typeof $Enums.SEXE

export type TEMPS = $Enums.TEMPS

export const TEMPS: typeof $Enums.TEMPS

export type TYPE_SPORT = $Enums.TYPE_SPORT

export const TYPE_SPORT: typeof $Enums.TYPE_SPORT

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Candidats
 * const candidats = await prisma.candidat.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Candidats
   * const candidats = await prisma.candidat.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.candidat`: Exposes CRUD operations for the **Candidat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidats
    * const candidats = await prisma.candidat.findMany()
    * ```
    */
  get candidat(): Prisma.CandidatDelegate<ExtArgs>;

  /**
   * `prisma.groupe`: Exposes CRUD operations for the **Groupe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupes
    * const groupes = await prisma.groupe.findMany()
    * ```
    */
  get groupe(): Prisma.GroupeDelegate<ExtArgs>;

  /**
   * `prisma.examinateur`: Exposes CRUD operations for the **Examinateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examinateurs
    * const examinateurs = await prisma.examinateur.findMany()
    * ```
    */
  get examinateur(): Prisma.ExaminateurDelegate<ExtArgs>;

  /**
   * `prisma.terrain`: Exposes CRUD operations for the **Terrain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terrains
    * const terrains = await prisma.terrain.findMany()
    * ```
    */
  get terrain(): Prisma.TerrainDelegate<ExtArgs>;

  /**
   * `prisma.centre`: Exposes CRUD operations for the **Centre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Centres
    * const centres = await prisma.centre.findMany()
    * ```
    */
  get centre(): Prisma.CentreDelegate<ExtArgs>;

  /**
   * `prisma.choix`: Exposes CRUD operations for the **Choix** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choixes
    * const choixes = await prisma.choix.findMany()
    * ```
    */
  get choix(): Prisma.ChoixDelegate<ExtArgs>;

  /**
   * `prisma.sport`: Exposes CRUD operations for the **Sport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sports
    * const sports = await prisma.sport.findMany()
    * ```
    */
  get sport(): Prisma.SportDelegate<ExtArgs>;

  /**
   * `prisma.utilisateur`: Exposes CRUD operations for the **Utilisateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateur.findMany()
    * ```
    */
  get utilisateur(): Prisma.UtilisateurDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.4.2
   * Query Engine version: ac9d7041ed77bcc8a8dbd2ab6616b39013829574
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Candidat: 'Candidat',
    Groupe: 'Groupe',
    Examinateur: 'Examinateur',
    Terrain: 'Terrain',
    Centre: 'Centre',
    Choix: 'Choix',
    Sport: 'Sport',
    Utilisateur: 'Utilisateur'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'candidat' | 'groupe' | 'examinateur' | 'terrain' | 'centre' | 'choix' | 'sport' | 'utilisateur'
      txIsolationLevel: never
    },
    model: {
      Candidat: {
        payload: Prisma.$CandidatPayload<ExtArgs>
        fields: Prisma.CandidatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          findFirst: {
            args: Prisma.CandidatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          findMany: {
            args: Prisma.CandidatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>[]
          }
          create: {
            args: Prisma.CandidatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          createMany: {
            args: Prisma.CandidatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CandidatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          update: {
            args: Prisma.CandidatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          deleteMany: {
            args: Prisma.CandidatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CandidatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CandidatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CandidatPayload>
          }
          aggregate: {
            args: Prisma.CandidatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCandidat>
          }
          groupBy: {
            args: Prisma.CandidatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CandidatGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CandidatFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CandidatAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CandidatCountArgs<ExtArgs>,
            result: $Utils.Optional<CandidatCountAggregateOutputType> | number
          }
        }
      }
      Groupe: {
        payload: Prisma.$GroupePayload<ExtArgs>
        fields: Prisma.GroupeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          findFirst: {
            args: Prisma.GroupeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          findMany: {
            args: Prisma.GroupeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>[]
          }
          create: {
            args: Prisma.GroupeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          createMany: {
            args: Prisma.GroupeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GroupeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          update: {
            args: Prisma.GroupeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          deleteMany: {
            args: Prisma.GroupeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroupeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroupeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          aggregate: {
            args: Prisma.GroupeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroupe>
          }
          groupBy: {
            args: Prisma.GroupeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GroupeFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.GroupeAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.GroupeCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupeCountAggregateOutputType> | number
          }
        }
      }
      Examinateur: {
        payload: Prisma.$ExaminateurPayload<ExtArgs>
        fields: Prisma.ExaminateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExaminateurFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExaminateurFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          findFirst: {
            args: Prisma.ExaminateurFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExaminateurFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          findMany: {
            args: Prisma.ExaminateurFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>[]
          }
          create: {
            args: Prisma.ExaminateurCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          createMany: {
            args: Prisma.ExaminateurCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExaminateurDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          update: {
            args: Prisma.ExaminateurUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          deleteMany: {
            args: Prisma.ExaminateurDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExaminateurUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExaminateurUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExaminateurPayload>
          }
          aggregate: {
            args: Prisma.ExaminateurAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExaminateur>
          }
          groupBy: {
            args: Prisma.ExaminateurGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExaminateurGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExaminateurFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExaminateurAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ExaminateurCountArgs<ExtArgs>,
            result: $Utils.Optional<ExaminateurCountAggregateOutputType> | number
          }
        }
      }
      Terrain: {
        payload: Prisma.$TerrainPayload<ExtArgs>
        fields: Prisma.TerrainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerrainFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerrainFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          findFirst: {
            args: Prisma.TerrainFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerrainFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          findMany: {
            args: Prisma.TerrainFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>[]
          }
          create: {
            args: Prisma.TerrainCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          createMany: {
            args: Prisma.TerrainCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TerrainDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          update: {
            args: Prisma.TerrainUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          deleteMany: {
            args: Prisma.TerrainDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TerrainUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TerrainUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TerrainPayload>
          }
          aggregate: {
            args: Prisma.TerrainAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTerrain>
          }
          groupBy: {
            args: Prisma.TerrainGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TerrainGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TerrainFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.TerrainAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.TerrainCountArgs<ExtArgs>,
            result: $Utils.Optional<TerrainCountAggregateOutputType> | number
          }
        }
      }
      Centre: {
        payload: Prisma.$CentrePayload<ExtArgs>
        fields: Prisma.CentreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CentreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CentreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          findFirst: {
            args: Prisma.CentreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CentreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          findMany: {
            args: Prisma.CentreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>[]
          }
          create: {
            args: Prisma.CentreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          createMany: {
            args: Prisma.CentreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CentreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          update: {
            args: Prisma.CentreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          deleteMany: {
            args: Prisma.CentreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CentreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CentreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CentrePayload>
          }
          aggregate: {
            args: Prisma.CentreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCentre>
          }
          groupBy: {
            args: Prisma.CentreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CentreGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CentreFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CentreAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CentreCountArgs<ExtArgs>,
            result: $Utils.Optional<CentreCountAggregateOutputType> | number
          }
        }
      }
      Choix: {
        payload: Prisma.$ChoixPayload<ExtArgs>
        fields: Prisma.ChoixFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoixFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoixFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          findFirst: {
            args: Prisma.ChoixFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoixFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          findMany: {
            args: Prisma.ChoixFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>[]
          }
          create: {
            args: Prisma.ChoixCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          createMany: {
            args: Prisma.ChoixCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ChoixDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          update: {
            args: Prisma.ChoixUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          deleteMany: {
            args: Prisma.ChoixDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ChoixUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ChoixUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ChoixPayload>
          }
          aggregate: {
            args: Prisma.ChoixAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateChoix>
          }
          groupBy: {
            args: Prisma.ChoixGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ChoixGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChoixFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChoixAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ChoixCountArgs<ExtArgs>,
            result: $Utils.Optional<ChoixCountAggregateOutputType> | number
          }
        }
      }
      Sport: {
        payload: Prisma.$SportPayload<ExtArgs>
        fields: Prisma.SportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findFirst: {
            args: Prisma.SportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findMany: {
            args: Prisma.SportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          create: {
            args: Prisma.SportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          createMany: {
            args: Prisma.SportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          update: {
            args: Prisma.SportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          deleteMany: {
            args: Prisma.SportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          aggregate: {
            args: Prisma.SportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSport>
          }
          groupBy: {
            args: Prisma.SportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SportFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SportAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SportCountArgs<ExtArgs>,
            result: $Utils.Optional<SportCountAggregateOutputType> | number
          }
        }
      }
      Utilisateur: {
        payload: Prisma.$UtilisateurPayload<ExtArgs>
        fields: Prisma.UtilisateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilisateurFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilisateurFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findFirst: {
            args: Prisma.UtilisateurFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilisateurFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findMany: {
            args: Prisma.UtilisateurFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          create: {
            args: Prisma.UtilisateurCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          createMany: {
            args: Prisma.UtilisateurCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UtilisateurDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          update: {
            args: Prisma.UtilisateurUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          deleteMany: {
            args: Prisma.UtilisateurDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UtilisateurUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UtilisateurUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          aggregate: {
            args: Prisma.UtilisateurAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUtilisateur>
          }
          groupBy: {
            args: Prisma.UtilisateurGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UtilisateurGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UtilisateurFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.UtilisateurAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.UtilisateurCountArgs<ExtArgs>,
            result: $Utils.Optional<UtilisateurCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CandidatCountOutputType
   */

  export type CandidatCountOutputType = {
    choix: number
  }

  export type CandidatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choix?: boolean | CandidatCountOutputTypeCountChoixArgs
  }

  // Custom InputTypes

  /**
   * CandidatCountOutputType without action
   */
  export type CandidatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidatCountOutputType
     */
    select?: CandidatCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CandidatCountOutputType without action
   */
  export type CandidatCountOutputTypeCountChoixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoixWhereInput
  }



  /**
   * Count Type ExaminateurCountOutputType
   */

  export type ExaminateurCountOutputType = {
    groupes: number
  }

  export type ExaminateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | ExaminateurCountOutputTypeCountGroupesArgs
  }

  // Custom InputTypes

  /**
   * ExaminateurCountOutputType without action
   */
  export type ExaminateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExaminateurCountOutputType
     */
    select?: ExaminateurCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ExaminateurCountOutputType without action
   */
  export type ExaminateurCountOutputTypeCountGroupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupeWhereInput
  }



  /**
   * Count Type TerrainCountOutputType
   */

  export type TerrainCountOutputType = {
    groupes: number
  }

  export type TerrainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | TerrainCountOutputTypeCountGroupesArgs
  }

  // Custom InputTypes

  /**
   * TerrainCountOutputType without action
   */
  export type TerrainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerrainCountOutputType
     */
    select?: TerrainCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TerrainCountOutputType without action
   */
  export type TerrainCountOutputTypeCountGroupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupeWhereInput
  }



  /**
   * Count Type CentreCountOutputType
   */

  export type CentreCountOutputType = {
    terrains: number
  }

  export type CentreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terrains?: boolean | CentreCountOutputTypeCountTerrainsArgs
  }

  // Custom InputTypes

  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreCountOutputType
     */
    select?: CentreCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CentreCountOutputType without action
   */
  export type CentreCountOutputTypeCountTerrainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerrainWhereInput
  }



  /**
   * Count Type SportCountOutputType
   */

  export type SportCountOutputType = {
    choix: number
  }

  export type SportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choix?: boolean | SportCountOutputTypeCountChoixArgs
  }

  // Custom InputTypes

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCountOutputType
     */
    select?: SportCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountChoixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoixWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Candidat
   */

  export type AggregateCandidat = {
    _count: CandidatCountAggregateOutputType | null
    _avg: CandidatAvgAggregateOutputType | null
    _sum: CandidatSumAggregateOutputType | null
    _min: CandidatMinAggregateOutputType | null
    _max: CandidatMaxAggregateOutputType | null
  }

  export type CandidatAvgAggregateOutputType = {
    numeroInscription: number | null
  }

  export type CandidatSumAggregateOutputType = {
    numeroInscription: number | null
  }

  export type CandidatMinAggregateOutputType = {
    id_candidat: string | null
    numeroInscription: number | null
    nom: string | null
    prenoms: string | null
    date_naissance: Date | null
    sexe: $Enums.SEXE | null
    isApte: boolean | null
  }

  export type CandidatMaxAggregateOutputType = {
    id_candidat: string | null
    numeroInscription: number | null
    nom: string | null
    prenoms: string | null
    date_naissance: Date | null
    sexe: $Enums.SEXE | null
    isApte: boolean | null
  }

  export type CandidatCountAggregateOutputType = {
    id_candidat: number
    numeroInscription: number
    nom: number
    prenoms: number
    date_naissance: number
    sexe: number
    isApte: number
    _all: number
  }


  export type CandidatAvgAggregateInputType = {
    numeroInscription?: true
  }

  export type CandidatSumAggregateInputType = {
    numeroInscription?: true
  }

  export type CandidatMinAggregateInputType = {
    id_candidat?: true
    numeroInscription?: true
    nom?: true
    prenoms?: true
    date_naissance?: true
    sexe?: true
    isApte?: true
  }

  export type CandidatMaxAggregateInputType = {
    id_candidat?: true
    numeroInscription?: true
    nom?: true
    prenoms?: true
    date_naissance?: true
    sexe?: true
    isApte?: true
  }

  export type CandidatCountAggregateInputType = {
    id_candidat?: true
    numeroInscription?: true
    nom?: true
    prenoms?: true
    date_naissance?: true
    sexe?: true
    isApte?: true
    _all?: true
  }

  export type CandidatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidat to aggregate.
     */
    where?: CandidatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidats to fetch.
     */
    orderBy?: CandidatOrderByWithRelationInput | CandidatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candidats
    **/
    _count?: true | CandidatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidatMaxAggregateInputType
  }

  export type GetCandidatAggregateType<T extends CandidatAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidat[P]>
      : GetScalarType<T[P], AggregateCandidat[P]>
  }




  export type CandidatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidatWhereInput
    orderBy?: CandidatOrderByWithAggregationInput | CandidatOrderByWithAggregationInput[]
    by: CandidatScalarFieldEnum[] | CandidatScalarFieldEnum
    having?: CandidatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidatCountAggregateInputType | true
    _avg?: CandidatAvgAggregateInputType
    _sum?: CandidatSumAggregateInputType
    _min?: CandidatMinAggregateInputType
    _max?: CandidatMaxAggregateInputType
  }

  export type CandidatGroupByOutputType = {
    id_candidat: string
    numeroInscription: number
    nom: string
    prenoms: string | null
    date_naissance: Date
    sexe: $Enums.SEXE
    isApte: boolean
    _count: CandidatCountAggregateOutputType | null
    _avg: CandidatAvgAggregateOutputType | null
    _sum: CandidatSumAggregateOutputType | null
    _min: CandidatMinAggregateOutputType | null
    _max: CandidatMaxAggregateOutputType | null
  }

  type GetCandidatGroupByPayload<T extends CandidatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidatGroupByOutputType[P]>
            : GetScalarType<T[P], CandidatGroupByOutputType[P]>
        }
      >
    >


  export type CandidatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_candidat?: boolean
    numeroInscription?: boolean
    nom?: boolean
    prenoms?: boolean
    date_naissance?: boolean
    sexe?: boolean
    isApte?: boolean
    choix?: boolean | Candidat$choixArgs<ExtArgs>
    _count?: boolean | CandidatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidat"]>

  export type CandidatSelectScalar = {
    id_candidat?: boolean
    numeroInscription?: boolean
    nom?: boolean
    prenoms?: boolean
    date_naissance?: boolean
    sexe?: boolean
    isApte?: boolean
  }

  export type CandidatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choix?: boolean | Candidat$choixArgs<ExtArgs>
    _count?: boolean | CandidatCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CandidatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candidat"
    objects: {
      choix: Prisma.$ChoixPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_candidat: string
      numeroInscription: number
      nom: string
      prenoms: string | null
      date_naissance: Date
      sexe: $Enums.SEXE
      isApte: boolean
    }, ExtArgs["result"]["candidat"]>
    composites: {}
  }


  type CandidatGetPayload<S extends boolean | null | undefined | CandidatDefaultArgs> = $Result.GetResult<Prisma.$CandidatPayload, S>

  type CandidatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandidatFindManyArgs, 'select' | 'include'> & {
      select?: CandidatCountAggregateInputType | true
    }

  export interface CandidatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candidat'], meta: { name: 'Candidat' } }
    /**
     * Find zero or one Candidat that matches the filter.
     * @param {CandidatFindUniqueArgs} args - Arguments to find a Candidat
     * @example
     * // Get one Candidat
     * const candidat = await prisma.candidat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CandidatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatFindUniqueArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Candidat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CandidatFindUniqueOrThrowArgs} args - Arguments to find a Candidat
     * @example
     * // Get one Candidat
     * const candidat = await prisma.candidat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CandidatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Candidat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatFindFirstArgs} args - Arguments to find a Candidat
     * @example
     * // Get one Candidat
     * const candidat = await prisma.candidat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CandidatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatFindFirstArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Candidat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatFindFirstOrThrowArgs} args - Arguments to find a Candidat
     * @example
     * // Get one Candidat
     * const candidat = await prisma.candidat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CandidatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Candidats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candidats
     * const candidats = await prisma.candidat.findMany()
     * 
     * // Get first 10 Candidats
     * const candidats = await prisma.candidat.findMany({ take: 10 })
     * 
     * // Only select the `id_candidat`
     * const candidatWithId_candidatOnly = await prisma.candidat.findMany({ select: { id_candidat: true } })
     * 
    **/
    findMany<T extends CandidatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Candidat.
     * @param {CandidatCreateArgs} args - Arguments to create a Candidat.
     * @example
     * // Create one Candidat
     * const Candidat = await prisma.candidat.create({
     *   data: {
     *     // ... data to create a Candidat
     *   }
     * })
     * 
    **/
    create<T extends CandidatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatCreateArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Candidats.
     *     @param {CandidatCreateManyArgs} args - Arguments to create many Candidats.
     *     @example
     *     // Create many Candidats
     *     const candidat = await prisma.candidat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CandidatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Candidat.
     * @param {CandidatDeleteArgs} args - Arguments to delete one Candidat.
     * @example
     * // Delete one Candidat
     * const Candidat = await prisma.candidat.delete({
     *   where: {
     *     // ... filter to delete one Candidat
     *   }
     * })
     * 
    **/
    delete<T extends CandidatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatDeleteArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Candidat.
     * @param {CandidatUpdateArgs} args - Arguments to update one Candidat.
     * @example
     * // Update one Candidat
     * const candidat = await prisma.candidat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CandidatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatUpdateArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Candidats.
     * @param {CandidatDeleteManyArgs} args - Arguments to filter Candidats to delete.
     * @example
     * // Delete a few Candidats
     * const { count } = await prisma.candidat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CandidatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CandidatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candidats
     * const candidat = await prisma.candidat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CandidatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Candidat.
     * @param {CandidatUpsertArgs} args - Arguments to update or create a Candidat.
     * @example
     * // Update or create a Candidat
     * const candidat = await prisma.candidat.upsert({
     *   create: {
     *     // ... data to create a Candidat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candidat we want to update
     *   }
     * })
    **/
    upsert<T extends CandidatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CandidatUpsertArgs<ExtArgs>>
    ): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Candidats that matches the filter.
     * @param {CandidatFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const candidat = await prisma.candidat.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CandidatFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Candidat.
     * @param {CandidatAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const candidat = await prisma.candidat.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CandidatAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Candidats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatCountArgs} args - Arguments to filter Candidats to count.
     * @example
     * // Count the number of Candidats
     * const count = await prisma.candidat.count({
     *   where: {
     *     // ... the filter for the Candidats we want to count
     *   }
     * })
    **/
    count<T extends CandidatCountArgs>(
      args?: Subset<T, CandidatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candidat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidatAggregateArgs>(args: Subset<T, CandidatAggregateArgs>): Prisma.PrismaPromise<GetCandidatAggregateType<T>>

    /**
     * Group by Candidat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidatGroupByArgs['orderBy'] }
        : { orderBy?: CandidatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candidat model
   */
  readonly fields: CandidatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candidat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    choix<T extends Candidat$choixArgs<ExtArgs> = {}>(args?: Subset<T, Candidat$choixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Candidat model
   */ 
  interface CandidatFieldRefs {
    readonly id_candidat: FieldRef<"Candidat", 'String'>
    readonly numeroInscription: FieldRef<"Candidat", 'Int'>
    readonly nom: FieldRef<"Candidat", 'String'>
    readonly prenoms: FieldRef<"Candidat", 'String'>
    readonly date_naissance: FieldRef<"Candidat", 'DateTime'>
    readonly sexe: FieldRef<"Candidat", 'SEXE'>
    readonly isApte: FieldRef<"Candidat", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Candidat findUnique
   */
  export type CandidatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter, which Candidat to fetch.
     */
    where: CandidatWhereUniqueInput
  }


  /**
   * Candidat findUniqueOrThrow
   */
  export type CandidatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter, which Candidat to fetch.
     */
    where: CandidatWhereUniqueInput
  }


  /**
   * Candidat findFirst
   */
  export type CandidatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter, which Candidat to fetch.
     */
    where?: CandidatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidats to fetch.
     */
    orderBy?: CandidatOrderByWithRelationInput | CandidatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidats.
     */
    cursor?: CandidatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidats.
     */
    distinct?: CandidatScalarFieldEnum | CandidatScalarFieldEnum[]
  }


  /**
   * Candidat findFirstOrThrow
   */
  export type CandidatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter, which Candidat to fetch.
     */
    where?: CandidatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidats to fetch.
     */
    orderBy?: CandidatOrderByWithRelationInput | CandidatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidats.
     */
    cursor?: CandidatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidats.
     */
    distinct?: CandidatScalarFieldEnum | CandidatScalarFieldEnum[]
  }


  /**
   * Candidat findMany
   */
  export type CandidatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter, which Candidats to fetch.
     */
    where?: CandidatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidats to fetch.
     */
    orderBy?: CandidatOrderByWithRelationInput | CandidatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candidats.
     */
    cursor?: CandidatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidats.
     */
    skip?: number
    distinct?: CandidatScalarFieldEnum | CandidatScalarFieldEnum[]
  }


  /**
   * Candidat create
   */
  export type CandidatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * The data needed to create a Candidat.
     */
    data: XOR<CandidatCreateInput, CandidatUncheckedCreateInput>
  }


  /**
   * Candidat createMany
   */
  export type CandidatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candidats.
     */
    data: CandidatCreateManyInput | CandidatCreateManyInput[]
  }


  /**
   * Candidat update
   */
  export type CandidatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * The data needed to update a Candidat.
     */
    data: XOR<CandidatUpdateInput, CandidatUncheckedUpdateInput>
    /**
     * Choose, which Candidat to update.
     */
    where: CandidatWhereUniqueInput
  }


  /**
   * Candidat updateMany
   */
  export type CandidatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candidats.
     */
    data: XOR<CandidatUpdateManyMutationInput, CandidatUncheckedUpdateManyInput>
    /**
     * Filter which Candidats to update
     */
    where?: CandidatWhereInput
  }


  /**
   * Candidat upsert
   */
  export type CandidatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * The filter to search for the Candidat to update in case it exists.
     */
    where: CandidatWhereUniqueInput
    /**
     * In case the Candidat found by the `where` argument doesn't exist, create a new Candidat with this data.
     */
    create: XOR<CandidatCreateInput, CandidatUncheckedCreateInput>
    /**
     * In case the Candidat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidatUpdateInput, CandidatUncheckedUpdateInput>
  }


  /**
   * Candidat delete
   */
  export type CandidatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
    /**
     * Filter which Candidat to delete.
     */
    where: CandidatWhereUniqueInput
  }


  /**
   * Candidat deleteMany
   */
  export type CandidatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidats to delete
     */
    where?: CandidatWhereInput
  }


  /**
   * Candidat findRaw
   */
  export type CandidatFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Candidat aggregateRaw
   */
  export type CandidatAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Candidat.choix
   */
  export type Candidat$choixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    where?: ChoixWhereInput
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    cursor?: ChoixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoixScalarFieldEnum | ChoixScalarFieldEnum[]
  }


  /**
   * Candidat without action
   */
  export type CandidatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidat
     */
    select?: CandidatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CandidatInclude<ExtArgs> | null
  }



  /**
   * Model Groupe
   */

  export type AggregateGroupe = {
    _count: GroupeCountAggregateOutputType | null
    _avg: GroupeAvgAggregateOutputType | null
    _sum: GroupeSumAggregateOutputType | null
    _min: GroupeMinAggregateOutputType | null
    _max: GroupeMaxAggregateOutputType | null
  }

  export type GroupeAvgAggregateOutputType = {
    numero: number | null
  }

  export type GroupeSumAggregateOutputType = {
    numero: number | null
  }

  export type GroupeMinAggregateOutputType = {
    id_groupe: string | null
    numero: number | null
    date_epreuve: Date | null
    temps: $Enums.TEMPS | null
    heure: string | null
    id_examinateur: string | null
    terrainId: string | null
  }

  export type GroupeMaxAggregateOutputType = {
    id_groupe: string | null
    numero: number | null
    date_epreuve: Date | null
    temps: $Enums.TEMPS | null
    heure: string | null
    id_examinateur: string | null
    terrainId: string | null
  }

  export type GroupeCountAggregateOutputType = {
    id_groupe: number
    numero: number
    date_epreuve: number
    temps: number
    heure: number
    id_examinateur: number
    terrainId: number
    _all: number
  }


  export type GroupeAvgAggregateInputType = {
    numero?: true
  }

  export type GroupeSumAggregateInputType = {
    numero?: true
  }

  export type GroupeMinAggregateInputType = {
    id_groupe?: true
    numero?: true
    date_epreuve?: true
    temps?: true
    heure?: true
    id_examinateur?: true
    terrainId?: true
  }

  export type GroupeMaxAggregateInputType = {
    id_groupe?: true
    numero?: true
    date_epreuve?: true
    temps?: true
    heure?: true
    id_examinateur?: true
    terrainId?: true
  }

  export type GroupeCountAggregateInputType = {
    id_groupe?: true
    numero?: true
    date_epreuve?: true
    temps?: true
    heure?: true
    id_examinateur?: true
    terrainId?: true
    _all?: true
  }

  export type GroupeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groupe to aggregate.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groupes
    **/
    _count?: true | GroupeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupeMaxAggregateInputType
  }

  export type GetGroupeAggregateType<T extends GroupeAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupe[P]>
      : GetScalarType<T[P], AggregateGroupe[P]>
  }




  export type GroupeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupeWhereInput
    orderBy?: GroupeOrderByWithAggregationInput | GroupeOrderByWithAggregationInput[]
    by: GroupeScalarFieldEnum[] | GroupeScalarFieldEnum
    having?: GroupeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupeCountAggregateInputType | true
    _avg?: GroupeAvgAggregateInputType
    _sum?: GroupeSumAggregateInputType
    _min?: GroupeMinAggregateInputType
    _max?: GroupeMaxAggregateInputType
  }

  export type GroupeGroupByOutputType = {
    id_groupe: string
    numero: number
    date_epreuve: Date
    temps: $Enums.TEMPS
    heure: string
    id_examinateur: string
    terrainId: string
    _count: GroupeCountAggregateOutputType | null
    _avg: GroupeAvgAggregateOutputType | null
    _sum: GroupeSumAggregateOutputType | null
    _min: GroupeMinAggregateOutputType | null
    _max: GroupeMaxAggregateOutputType | null
  }

  type GetGroupeGroupByPayload<T extends GroupeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupeGroupByOutputType[P]>
            : GetScalarType<T[P], GroupeGroupByOutputType[P]>
        }
      >
    >


  export type GroupeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_groupe?: boolean
    numero?: boolean
    date_epreuve?: boolean
    temps?: boolean
    heure?: boolean
    id_examinateur?: boolean
    terrainId?: boolean
    examinateur?: boolean | ExaminateurDefaultArgs<ExtArgs>
    terrain?: boolean | TerrainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupe"]>

  export type GroupeSelectScalar = {
    id_groupe?: boolean
    numero?: boolean
    date_epreuve?: boolean
    temps?: boolean
    heure?: boolean
    id_examinateur?: boolean
    terrainId?: boolean
  }

  export type GroupeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examinateur?: boolean | ExaminateurDefaultArgs<ExtArgs>
    terrain?: boolean | TerrainDefaultArgs<ExtArgs>
  }


  export type $GroupePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Groupe"
    objects: {
      examinateur: Prisma.$ExaminateurPayload<ExtArgs>
      terrain: Prisma.$TerrainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_groupe: string
      numero: number
      date_epreuve: Date
      temps: $Enums.TEMPS
      heure: string
      id_examinateur: string
      terrainId: string
    }, ExtArgs["result"]["groupe"]>
    composites: {}
  }


  type GroupeGetPayload<S extends boolean | null | undefined | GroupeDefaultArgs> = $Result.GetResult<Prisma.$GroupePayload, S>

  type GroupeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupeFindManyArgs, 'select' | 'include'> & {
      select?: GroupeCountAggregateInputType | true
    }

  export interface GroupeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Groupe'], meta: { name: 'Groupe' } }
    /**
     * Find zero or one Groupe that matches the filter.
     * @param {GroupeFindUniqueArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeFindUniqueArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Groupe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupeFindUniqueOrThrowArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Groupe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindFirstArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeFindFirstArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Groupe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindFirstOrThrowArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupes
     * const groupes = await prisma.groupe.findMany()
     * 
     * // Get first 10 Groupes
     * const groupes = await prisma.groupe.findMany({ take: 10 })
     * 
     * // Only select the `id_groupe`
     * const groupeWithId_groupeOnly = await prisma.groupe.findMany({ select: { id_groupe: true } })
     * 
    **/
    findMany<T extends GroupeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Groupe.
     * @param {GroupeCreateArgs} args - Arguments to create a Groupe.
     * @example
     * // Create one Groupe
     * const Groupe = await prisma.groupe.create({
     *   data: {
     *     // ... data to create a Groupe
     *   }
     * })
     * 
    **/
    create<T extends GroupeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeCreateArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groupes.
     *     @param {GroupeCreateManyArgs} args - Arguments to create many Groupes.
     *     @example
     *     // Create many Groupes
     *     const groupe = await prisma.groupe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groupe.
     * @param {GroupeDeleteArgs} args - Arguments to delete one Groupe.
     * @example
     * // Delete one Groupe
     * const Groupe = await prisma.groupe.delete({
     *   where: {
     *     // ... filter to delete one Groupe
     *   }
     * })
     * 
    **/
    delete<T extends GroupeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeDeleteArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Groupe.
     * @param {GroupeUpdateArgs} args - Arguments to update one Groupe.
     * @example
     * // Update one Groupe
     * const groupe = await prisma.groupe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeUpdateArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groupes.
     * @param {GroupeDeleteManyArgs} args - Arguments to filter Groupes to delete.
     * @example
     * // Delete a few Groupes
     * const { count } = await prisma.groupe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupes
     * const groupe = await prisma.groupe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupe.
     * @param {GroupeUpsertArgs} args - Arguments to update or create a Groupe.
     * @example
     * // Update or create a Groupe
     * const groupe = await prisma.groupe.upsert({
     *   create: {
     *     // ... data to create a Groupe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupe we want to update
     *   }
     * })
    **/
    upsert<T extends GroupeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroupeUpsertArgs<ExtArgs>>
    ): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Groupes that matches the filter.
     * @param {GroupeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const groupe = await prisma.groupe.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: GroupeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Groupe.
     * @param {GroupeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const groupe = await prisma.groupe.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: GroupeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeCountArgs} args - Arguments to filter Groupes to count.
     * @example
     * // Count the number of Groupes
     * const count = await prisma.groupe.count({
     *   where: {
     *     // ... the filter for the Groupes we want to count
     *   }
     * })
    **/
    count<T extends GroupeCountArgs>(
      args?: Subset<T, GroupeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupeAggregateArgs>(args: Subset<T, GroupeAggregateArgs>): Prisma.PrismaPromise<GetGroupeAggregateType<T>>

    /**
     * Group by Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupeGroupByArgs['orderBy'] }
        : { orderBy?: GroupeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Groupe model
   */
  readonly fields: GroupeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Groupe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    examinateur<T extends ExaminateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExaminateurDefaultArgs<ExtArgs>>): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    terrain<T extends TerrainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerrainDefaultArgs<ExtArgs>>): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Groupe model
   */ 
  interface GroupeFieldRefs {
    readonly id_groupe: FieldRef<"Groupe", 'String'>
    readonly numero: FieldRef<"Groupe", 'Int'>
    readonly date_epreuve: FieldRef<"Groupe", 'DateTime'>
    readonly temps: FieldRef<"Groupe", 'TEMPS'>
    readonly heure: FieldRef<"Groupe", 'String'>
    readonly id_examinateur: FieldRef<"Groupe", 'String'>
    readonly terrainId: FieldRef<"Groupe", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Groupe findUnique
   */
  export type GroupeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where: GroupeWhereUniqueInput
  }


  /**
   * Groupe findUniqueOrThrow
   */
  export type GroupeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where: GroupeWhereUniqueInput
  }


  /**
   * Groupe findFirst
   */
  export type GroupeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groupes.
     */
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }


  /**
   * Groupe findFirstOrThrow
   */
  export type GroupeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groupes.
     */
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }


  /**
   * Groupe findMany
   */
  export type GroupeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupes to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }


  /**
   * Groupe create
   */
  export type GroupeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The data needed to create a Groupe.
     */
    data: XOR<GroupeCreateInput, GroupeUncheckedCreateInput>
  }


  /**
   * Groupe createMany
   */
  export type GroupeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groupes.
     */
    data: GroupeCreateManyInput | GroupeCreateManyInput[]
  }


  /**
   * Groupe update
   */
  export type GroupeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The data needed to update a Groupe.
     */
    data: XOR<GroupeUpdateInput, GroupeUncheckedUpdateInput>
    /**
     * Choose, which Groupe to update.
     */
    where: GroupeWhereUniqueInput
  }


  /**
   * Groupe updateMany
   */
  export type GroupeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groupes.
     */
    data: XOR<GroupeUpdateManyMutationInput, GroupeUncheckedUpdateManyInput>
    /**
     * Filter which Groupes to update
     */
    where?: GroupeWhereInput
  }


  /**
   * Groupe upsert
   */
  export type GroupeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The filter to search for the Groupe to update in case it exists.
     */
    where: GroupeWhereUniqueInput
    /**
     * In case the Groupe found by the `where` argument doesn't exist, create a new Groupe with this data.
     */
    create: XOR<GroupeCreateInput, GroupeUncheckedCreateInput>
    /**
     * In case the Groupe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupeUpdateInput, GroupeUncheckedUpdateInput>
  }


  /**
   * Groupe delete
   */
  export type GroupeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter which Groupe to delete.
     */
    where: GroupeWhereUniqueInput
  }


  /**
   * Groupe deleteMany
   */
  export type GroupeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groupes to delete
     */
    where?: GroupeWhereInput
  }


  /**
   * Groupe findRaw
   */
  export type GroupeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Groupe aggregateRaw
   */
  export type GroupeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Groupe without action
   */
  export type GroupeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
  }



  /**
   * Model Examinateur
   */

  export type AggregateExaminateur = {
    _count: ExaminateurCountAggregateOutputType | null
    _min: ExaminateurMinAggregateOutputType | null
    _max: ExaminateurMaxAggregateOutputType | null
  }

  export type ExaminateurMinAggregateOutputType = {
    id_examinateur: string | null
    nom_examinateur: string | null
  }

  export type ExaminateurMaxAggregateOutputType = {
    id_examinateur: string | null
    nom_examinateur: string | null
  }

  export type ExaminateurCountAggregateOutputType = {
    id_examinateur: number
    nom_examinateur: number
    _all: number
  }


  export type ExaminateurMinAggregateInputType = {
    id_examinateur?: true
    nom_examinateur?: true
  }

  export type ExaminateurMaxAggregateInputType = {
    id_examinateur?: true
    nom_examinateur?: true
  }

  export type ExaminateurCountAggregateInputType = {
    id_examinateur?: true
    nom_examinateur?: true
    _all?: true
  }

  export type ExaminateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examinateur to aggregate.
     */
    where?: ExaminateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examinateurs to fetch.
     */
    orderBy?: ExaminateurOrderByWithRelationInput | ExaminateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExaminateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examinateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examinateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Examinateurs
    **/
    _count?: true | ExaminateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExaminateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExaminateurMaxAggregateInputType
  }

  export type GetExaminateurAggregateType<T extends ExaminateurAggregateArgs> = {
        [P in keyof T & keyof AggregateExaminateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExaminateur[P]>
      : GetScalarType<T[P], AggregateExaminateur[P]>
  }




  export type ExaminateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExaminateurWhereInput
    orderBy?: ExaminateurOrderByWithAggregationInput | ExaminateurOrderByWithAggregationInput[]
    by: ExaminateurScalarFieldEnum[] | ExaminateurScalarFieldEnum
    having?: ExaminateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExaminateurCountAggregateInputType | true
    _min?: ExaminateurMinAggregateInputType
    _max?: ExaminateurMaxAggregateInputType
  }

  export type ExaminateurGroupByOutputType = {
    id_examinateur: string
    nom_examinateur: string
    _count: ExaminateurCountAggregateOutputType | null
    _min: ExaminateurMinAggregateOutputType | null
    _max: ExaminateurMaxAggregateOutputType | null
  }

  type GetExaminateurGroupByPayload<T extends ExaminateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExaminateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExaminateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExaminateurGroupByOutputType[P]>
            : GetScalarType<T[P], ExaminateurGroupByOutputType[P]>
        }
      >
    >


  export type ExaminateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_examinateur?: boolean
    nom_examinateur?: boolean
    groupes?: boolean | Examinateur$groupesArgs<ExtArgs>
    _count?: boolean | ExaminateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examinateur"]>

  export type ExaminateurSelectScalar = {
    id_examinateur?: boolean
    nom_examinateur?: boolean
  }

  export type ExaminateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | Examinateur$groupesArgs<ExtArgs>
    _count?: boolean | ExaminateurCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ExaminateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Examinateur"
    objects: {
      groupes: Prisma.$GroupePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_examinateur: string
      nom_examinateur: string
    }, ExtArgs["result"]["examinateur"]>
    composites: {}
  }


  type ExaminateurGetPayload<S extends boolean | null | undefined | ExaminateurDefaultArgs> = $Result.GetResult<Prisma.$ExaminateurPayload, S>

  type ExaminateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExaminateurFindManyArgs, 'select' | 'include'> & {
      select?: ExaminateurCountAggregateInputType | true
    }

  export interface ExaminateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Examinateur'], meta: { name: 'Examinateur' } }
    /**
     * Find zero or one Examinateur that matches the filter.
     * @param {ExaminateurFindUniqueArgs} args - Arguments to find a Examinateur
     * @example
     * // Get one Examinateur
     * const examinateur = await prisma.examinateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExaminateurFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurFindUniqueArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Examinateur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExaminateurFindUniqueOrThrowArgs} args - Arguments to find a Examinateur
     * @example
     * // Get one Examinateur
     * const examinateur = await prisma.examinateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExaminateurFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Examinateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurFindFirstArgs} args - Arguments to find a Examinateur
     * @example
     * // Get one Examinateur
     * const examinateur = await prisma.examinateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExaminateurFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurFindFirstArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Examinateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurFindFirstOrThrowArgs} args - Arguments to find a Examinateur
     * @example
     * // Get one Examinateur
     * const examinateur = await prisma.examinateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExaminateurFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Examinateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examinateurs
     * const examinateurs = await prisma.examinateur.findMany()
     * 
     * // Get first 10 Examinateurs
     * const examinateurs = await prisma.examinateur.findMany({ take: 10 })
     * 
     * // Only select the `id_examinateur`
     * const examinateurWithId_examinateurOnly = await prisma.examinateur.findMany({ select: { id_examinateur: true } })
     * 
    **/
    findMany<T extends ExaminateurFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Examinateur.
     * @param {ExaminateurCreateArgs} args - Arguments to create a Examinateur.
     * @example
     * // Create one Examinateur
     * const Examinateur = await prisma.examinateur.create({
     *   data: {
     *     // ... data to create a Examinateur
     *   }
     * })
     * 
    **/
    create<T extends ExaminateurCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurCreateArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Examinateurs.
     *     @param {ExaminateurCreateManyArgs} args - Arguments to create many Examinateurs.
     *     @example
     *     // Create many Examinateurs
     *     const examinateur = await prisma.examinateur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExaminateurCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Examinateur.
     * @param {ExaminateurDeleteArgs} args - Arguments to delete one Examinateur.
     * @example
     * // Delete one Examinateur
     * const Examinateur = await prisma.examinateur.delete({
     *   where: {
     *     // ... filter to delete one Examinateur
     *   }
     * })
     * 
    **/
    delete<T extends ExaminateurDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurDeleteArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Examinateur.
     * @param {ExaminateurUpdateArgs} args - Arguments to update one Examinateur.
     * @example
     * // Update one Examinateur
     * const examinateur = await prisma.examinateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExaminateurUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurUpdateArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Examinateurs.
     * @param {ExaminateurDeleteManyArgs} args - Arguments to filter Examinateurs to delete.
     * @example
     * // Delete a few Examinateurs
     * const { count } = await prisma.examinateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExaminateurDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExaminateurDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examinateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examinateurs
     * const examinateur = await prisma.examinateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExaminateurUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Examinateur.
     * @param {ExaminateurUpsertArgs} args - Arguments to update or create a Examinateur.
     * @example
     * // Update or create a Examinateur
     * const examinateur = await prisma.examinateur.upsert({
     *   create: {
     *     // ... data to create a Examinateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examinateur we want to update
     *   }
     * })
    **/
    upsert<T extends ExaminateurUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExaminateurUpsertArgs<ExtArgs>>
    ): Prisma__ExaminateurClient<$Result.GetResult<Prisma.$ExaminateurPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Examinateurs that matches the filter.
     * @param {ExaminateurFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const examinateur = await prisma.examinateur.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ExaminateurFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Examinateur.
     * @param {ExaminateurAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const examinateur = await prisma.examinateur.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ExaminateurAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Examinateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurCountArgs} args - Arguments to filter Examinateurs to count.
     * @example
     * // Count the number of Examinateurs
     * const count = await prisma.examinateur.count({
     *   where: {
     *     // ... the filter for the Examinateurs we want to count
     *   }
     * })
    **/
    count<T extends ExaminateurCountArgs>(
      args?: Subset<T, ExaminateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExaminateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examinateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExaminateurAggregateArgs>(args: Subset<T, ExaminateurAggregateArgs>): Prisma.PrismaPromise<GetExaminateurAggregateType<T>>

    /**
     * Group by Examinateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExaminateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExaminateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExaminateurGroupByArgs['orderBy'] }
        : { orderBy?: ExaminateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExaminateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExaminateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Examinateur model
   */
  readonly fields: ExaminateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Examinateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExaminateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groupes<T extends Examinateur$groupesArgs<ExtArgs> = {}>(args?: Subset<T, Examinateur$groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Examinateur model
   */ 
  interface ExaminateurFieldRefs {
    readonly id_examinateur: FieldRef<"Examinateur", 'String'>
    readonly nom_examinateur: FieldRef<"Examinateur", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Examinateur findUnique
   */
  export type ExaminateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter, which Examinateur to fetch.
     */
    where: ExaminateurWhereUniqueInput
  }


  /**
   * Examinateur findUniqueOrThrow
   */
  export type ExaminateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter, which Examinateur to fetch.
     */
    where: ExaminateurWhereUniqueInput
  }


  /**
   * Examinateur findFirst
   */
  export type ExaminateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter, which Examinateur to fetch.
     */
    where?: ExaminateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examinateurs to fetch.
     */
    orderBy?: ExaminateurOrderByWithRelationInput | ExaminateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examinateurs.
     */
    cursor?: ExaminateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examinateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examinateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examinateurs.
     */
    distinct?: ExaminateurScalarFieldEnum | ExaminateurScalarFieldEnum[]
  }


  /**
   * Examinateur findFirstOrThrow
   */
  export type ExaminateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter, which Examinateur to fetch.
     */
    where?: ExaminateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examinateurs to fetch.
     */
    orderBy?: ExaminateurOrderByWithRelationInput | ExaminateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examinateurs.
     */
    cursor?: ExaminateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examinateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examinateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examinateurs.
     */
    distinct?: ExaminateurScalarFieldEnum | ExaminateurScalarFieldEnum[]
  }


  /**
   * Examinateur findMany
   */
  export type ExaminateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter, which Examinateurs to fetch.
     */
    where?: ExaminateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examinateurs to fetch.
     */
    orderBy?: ExaminateurOrderByWithRelationInput | ExaminateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Examinateurs.
     */
    cursor?: ExaminateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examinateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examinateurs.
     */
    skip?: number
    distinct?: ExaminateurScalarFieldEnum | ExaminateurScalarFieldEnum[]
  }


  /**
   * Examinateur create
   */
  export type ExaminateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * The data needed to create a Examinateur.
     */
    data: XOR<ExaminateurCreateInput, ExaminateurUncheckedCreateInput>
  }


  /**
   * Examinateur createMany
   */
  export type ExaminateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Examinateurs.
     */
    data: ExaminateurCreateManyInput | ExaminateurCreateManyInput[]
  }


  /**
   * Examinateur update
   */
  export type ExaminateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * The data needed to update a Examinateur.
     */
    data: XOR<ExaminateurUpdateInput, ExaminateurUncheckedUpdateInput>
    /**
     * Choose, which Examinateur to update.
     */
    where: ExaminateurWhereUniqueInput
  }


  /**
   * Examinateur updateMany
   */
  export type ExaminateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Examinateurs.
     */
    data: XOR<ExaminateurUpdateManyMutationInput, ExaminateurUncheckedUpdateManyInput>
    /**
     * Filter which Examinateurs to update
     */
    where?: ExaminateurWhereInput
  }


  /**
   * Examinateur upsert
   */
  export type ExaminateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * The filter to search for the Examinateur to update in case it exists.
     */
    where: ExaminateurWhereUniqueInput
    /**
     * In case the Examinateur found by the `where` argument doesn't exist, create a new Examinateur with this data.
     */
    create: XOR<ExaminateurCreateInput, ExaminateurUncheckedCreateInput>
    /**
     * In case the Examinateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExaminateurUpdateInput, ExaminateurUncheckedUpdateInput>
  }


  /**
   * Examinateur delete
   */
  export type ExaminateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
    /**
     * Filter which Examinateur to delete.
     */
    where: ExaminateurWhereUniqueInput
  }


  /**
   * Examinateur deleteMany
   */
  export type ExaminateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examinateurs to delete
     */
    where?: ExaminateurWhereInput
  }


  /**
   * Examinateur findRaw
   */
  export type ExaminateurFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Examinateur aggregateRaw
   */
  export type ExaminateurAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Examinateur.groupes
   */
  export type Examinateur$groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    where?: GroupeWhereInput
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    cursor?: GroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }


  /**
   * Examinateur without action
   */
  export type ExaminateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Examinateur
     */
    select?: ExaminateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExaminateurInclude<ExtArgs> | null
  }



  /**
   * Model Terrain
   */

  export type AggregateTerrain = {
    _count: TerrainCountAggregateOutputType | null
    _min: TerrainMinAggregateOutputType | null
    _max: TerrainMaxAggregateOutputType | null
  }

  export type TerrainMinAggregateOutputType = {
    id_terrain: string | null
    nom_terrain: string | null
    id_centre: string | null
  }

  export type TerrainMaxAggregateOutputType = {
    id_terrain: string | null
    nom_terrain: string | null
    id_centre: string | null
  }

  export type TerrainCountAggregateOutputType = {
    id_terrain: number
    nom_terrain: number
    id_centre: number
    _all: number
  }


  export type TerrainMinAggregateInputType = {
    id_terrain?: true
    nom_terrain?: true
    id_centre?: true
  }

  export type TerrainMaxAggregateInputType = {
    id_terrain?: true
    nom_terrain?: true
    id_centre?: true
  }

  export type TerrainCountAggregateInputType = {
    id_terrain?: true
    nom_terrain?: true
    id_centre?: true
    _all?: true
  }

  export type TerrainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terrain to aggregate.
     */
    where?: TerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terrains to fetch.
     */
    orderBy?: TerrainOrderByWithRelationInput | TerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terrains
    **/
    _count?: true | TerrainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerrainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerrainMaxAggregateInputType
  }

  export type GetTerrainAggregateType<T extends TerrainAggregateArgs> = {
        [P in keyof T & keyof AggregateTerrain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerrain[P]>
      : GetScalarType<T[P], AggregateTerrain[P]>
  }




  export type TerrainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerrainWhereInput
    orderBy?: TerrainOrderByWithAggregationInput | TerrainOrderByWithAggregationInput[]
    by: TerrainScalarFieldEnum[] | TerrainScalarFieldEnum
    having?: TerrainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerrainCountAggregateInputType | true
    _min?: TerrainMinAggregateInputType
    _max?: TerrainMaxAggregateInputType
  }

  export type TerrainGroupByOutputType = {
    id_terrain: string
    nom_terrain: string
    id_centre: string
    _count: TerrainCountAggregateOutputType | null
    _min: TerrainMinAggregateOutputType | null
    _max: TerrainMaxAggregateOutputType | null
  }

  type GetTerrainGroupByPayload<T extends TerrainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerrainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerrainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerrainGroupByOutputType[P]>
            : GetScalarType<T[P], TerrainGroupByOutputType[P]>
        }
      >
    >


  export type TerrainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_terrain?: boolean
    nom_terrain?: boolean
    id_centre?: boolean
    centre?: boolean | CentreDefaultArgs<ExtArgs>
    groupes?: boolean | Terrain$groupesArgs<ExtArgs>
    _count?: boolean | TerrainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terrain"]>

  export type TerrainSelectScalar = {
    id_terrain?: boolean
    nom_terrain?: boolean
    id_centre?: boolean
  }

  export type TerrainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    centre?: boolean | CentreDefaultArgs<ExtArgs>
    groupes?: boolean | Terrain$groupesArgs<ExtArgs>
    _count?: boolean | TerrainCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TerrainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Terrain"
    objects: {
      centre: Prisma.$CentrePayload<ExtArgs>
      groupes: Prisma.$GroupePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_terrain: string
      nom_terrain: string
      id_centre: string
    }, ExtArgs["result"]["terrain"]>
    composites: {}
  }


  type TerrainGetPayload<S extends boolean | null | undefined | TerrainDefaultArgs> = $Result.GetResult<Prisma.$TerrainPayload, S>

  type TerrainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TerrainFindManyArgs, 'select' | 'include'> & {
      select?: TerrainCountAggregateInputType | true
    }

  export interface TerrainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Terrain'], meta: { name: 'Terrain' } }
    /**
     * Find zero or one Terrain that matches the filter.
     * @param {TerrainFindUniqueArgs} args - Arguments to find a Terrain
     * @example
     * // Get one Terrain
     * const terrain = await prisma.terrain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TerrainFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainFindUniqueArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Terrain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TerrainFindUniqueOrThrowArgs} args - Arguments to find a Terrain
     * @example
     * // Get one Terrain
     * const terrain = await prisma.terrain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TerrainFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Terrain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainFindFirstArgs} args - Arguments to find a Terrain
     * @example
     * // Get one Terrain
     * const terrain = await prisma.terrain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TerrainFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainFindFirstArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Terrain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainFindFirstOrThrowArgs} args - Arguments to find a Terrain
     * @example
     * // Get one Terrain
     * const terrain = await prisma.terrain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TerrainFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Terrains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terrains
     * const terrains = await prisma.terrain.findMany()
     * 
     * // Get first 10 Terrains
     * const terrains = await prisma.terrain.findMany({ take: 10 })
     * 
     * // Only select the `id_terrain`
     * const terrainWithId_terrainOnly = await prisma.terrain.findMany({ select: { id_terrain: true } })
     * 
    **/
    findMany<T extends TerrainFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Terrain.
     * @param {TerrainCreateArgs} args - Arguments to create a Terrain.
     * @example
     * // Create one Terrain
     * const Terrain = await prisma.terrain.create({
     *   data: {
     *     // ... data to create a Terrain
     *   }
     * })
     * 
    **/
    create<T extends TerrainCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainCreateArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Terrains.
     *     @param {TerrainCreateManyArgs} args - Arguments to create many Terrains.
     *     @example
     *     // Create many Terrains
     *     const terrain = await prisma.terrain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TerrainCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Terrain.
     * @param {TerrainDeleteArgs} args - Arguments to delete one Terrain.
     * @example
     * // Delete one Terrain
     * const Terrain = await prisma.terrain.delete({
     *   where: {
     *     // ... filter to delete one Terrain
     *   }
     * })
     * 
    **/
    delete<T extends TerrainDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainDeleteArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Terrain.
     * @param {TerrainUpdateArgs} args - Arguments to update one Terrain.
     * @example
     * // Update one Terrain
     * const terrain = await prisma.terrain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TerrainUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainUpdateArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Terrains.
     * @param {TerrainDeleteManyArgs} args - Arguments to filter Terrains to delete.
     * @example
     * // Delete a few Terrains
     * const { count } = await prisma.terrain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TerrainDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TerrainDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terrains
     * const terrain = await prisma.terrain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TerrainUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terrain.
     * @param {TerrainUpsertArgs} args - Arguments to update or create a Terrain.
     * @example
     * // Update or create a Terrain
     * const terrain = await prisma.terrain.upsert({
     *   create: {
     *     // ... data to create a Terrain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terrain we want to update
     *   }
     * })
    **/
    upsert<T extends TerrainUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TerrainUpsertArgs<ExtArgs>>
    ): Prisma__TerrainClient<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Terrains that matches the filter.
     * @param {TerrainFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const terrain = await prisma.terrain.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TerrainFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Terrain.
     * @param {TerrainAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const terrain = await prisma.terrain.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TerrainAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Terrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainCountArgs} args - Arguments to filter Terrains to count.
     * @example
     * // Count the number of Terrains
     * const count = await prisma.terrain.count({
     *   where: {
     *     // ... the filter for the Terrains we want to count
     *   }
     * })
    **/
    count<T extends TerrainCountArgs>(
      args?: Subset<T, TerrainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerrainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerrainAggregateArgs>(args: Subset<T, TerrainAggregateArgs>): Prisma.PrismaPromise<GetTerrainAggregateType<T>>

    /**
     * Group by Terrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerrainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerrainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerrainGroupByArgs['orderBy'] }
        : { orderBy?: TerrainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerrainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerrainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Terrain model
   */
  readonly fields: TerrainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Terrain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerrainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    centre<T extends CentreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CentreDefaultArgs<ExtArgs>>): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    groupes<T extends Terrain$groupesArgs<ExtArgs> = {}>(args?: Subset<T, Terrain$groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Terrain model
   */ 
  interface TerrainFieldRefs {
    readonly id_terrain: FieldRef<"Terrain", 'String'>
    readonly nom_terrain: FieldRef<"Terrain", 'String'>
    readonly id_centre: FieldRef<"Terrain", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Terrain findUnique
   */
  export type TerrainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter, which Terrain to fetch.
     */
    where: TerrainWhereUniqueInput
  }


  /**
   * Terrain findUniqueOrThrow
   */
  export type TerrainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter, which Terrain to fetch.
     */
    where: TerrainWhereUniqueInput
  }


  /**
   * Terrain findFirst
   */
  export type TerrainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter, which Terrain to fetch.
     */
    where?: TerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terrains to fetch.
     */
    orderBy?: TerrainOrderByWithRelationInput | TerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terrains.
     */
    cursor?: TerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terrains.
     */
    distinct?: TerrainScalarFieldEnum | TerrainScalarFieldEnum[]
  }


  /**
   * Terrain findFirstOrThrow
   */
  export type TerrainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter, which Terrain to fetch.
     */
    where?: TerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terrains to fetch.
     */
    orderBy?: TerrainOrderByWithRelationInput | TerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terrains.
     */
    cursor?: TerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terrains.
     */
    distinct?: TerrainScalarFieldEnum | TerrainScalarFieldEnum[]
  }


  /**
   * Terrain findMany
   */
  export type TerrainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter, which Terrains to fetch.
     */
    where?: TerrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terrains to fetch.
     */
    orderBy?: TerrainOrderByWithRelationInput | TerrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terrains.
     */
    cursor?: TerrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terrains.
     */
    skip?: number
    distinct?: TerrainScalarFieldEnum | TerrainScalarFieldEnum[]
  }


  /**
   * Terrain create
   */
  export type TerrainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * The data needed to create a Terrain.
     */
    data: XOR<TerrainCreateInput, TerrainUncheckedCreateInput>
  }


  /**
   * Terrain createMany
   */
  export type TerrainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terrains.
     */
    data: TerrainCreateManyInput | TerrainCreateManyInput[]
  }


  /**
   * Terrain update
   */
  export type TerrainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * The data needed to update a Terrain.
     */
    data: XOR<TerrainUpdateInput, TerrainUncheckedUpdateInput>
    /**
     * Choose, which Terrain to update.
     */
    where: TerrainWhereUniqueInput
  }


  /**
   * Terrain updateMany
   */
  export type TerrainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terrains.
     */
    data: XOR<TerrainUpdateManyMutationInput, TerrainUncheckedUpdateManyInput>
    /**
     * Filter which Terrains to update
     */
    where?: TerrainWhereInput
  }


  /**
   * Terrain upsert
   */
  export type TerrainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * The filter to search for the Terrain to update in case it exists.
     */
    where: TerrainWhereUniqueInput
    /**
     * In case the Terrain found by the `where` argument doesn't exist, create a new Terrain with this data.
     */
    create: XOR<TerrainCreateInput, TerrainUncheckedCreateInput>
    /**
     * In case the Terrain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerrainUpdateInput, TerrainUncheckedUpdateInput>
  }


  /**
   * Terrain delete
   */
  export type TerrainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    /**
     * Filter which Terrain to delete.
     */
    where: TerrainWhereUniqueInput
  }


  /**
   * Terrain deleteMany
   */
  export type TerrainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terrains to delete
     */
    where?: TerrainWhereInput
  }


  /**
   * Terrain findRaw
   */
  export type TerrainFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Terrain aggregateRaw
   */
  export type TerrainAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Terrain.groupes
   */
  export type Terrain$groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupeInclude<ExtArgs> | null
    where?: GroupeWhereInput
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    cursor?: GroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }


  /**
   * Terrain without action
   */
  export type TerrainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
  }



  /**
   * Model Centre
   */

  export type AggregateCentre = {
    _count: CentreCountAggregateOutputType | null
    _min: CentreMinAggregateOutputType | null
    _max: CentreMaxAggregateOutputType | null
  }

  export type CentreMinAggregateOutputType = {
    id_centre: string | null
    lieu: string | null
  }

  export type CentreMaxAggregateOutputType = {
    id_centre: string | null
    lieu: string | null
  }

  export type CentreCountAggregateOutputType = {
    id_centre: number
    lieu: number
    _all: number
  }


  export type CentreMinAggregateInputType = {
    id_centre?: true
    lieu?: true
  }

  export type CentreMaxAggregateInputType = {
    id_centre?: true
    lieu?: true
  }

  export type CentreCountAggregateInputType = {
    id_centre?: true
    lieu?: true
    _all?: true
  }

  export type CentreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Centre to aggregate.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Centres
    **/
    _count?: true | CentreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CentreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CentreMaxAggregateInputType
  }

  export type GetCentreAggregateType<T extends CentreAggregateArgs> = {
        [P in keyof T & keyof AggregateCentre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCentre[P]>
      : GetScalarType<T[P], AggregateCentre[P]>
  }




  export type CentreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CentreWhereInput
    orderBy?: CentreOrderByWithAggregationInput | CentreOrderByWithAggregationInput[]
    by: CentreScalarFieldEnum[] | CentreScalarFieldEnum
    having?: CentreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CentreCountAggregateInputType | true
    _min?: CentreMinAggregateInputType
    _max?: CentreMaxAggregateInputType
  }

  export type CentreGroupByOutputType = {
    id_centre: string
    lieu: string
    _count: CentreCountAggregateOutputType | null
    _min: CentreMinAggregateOutputType | null
    _max: CentreMaxAggregateOutputType | null
  }

  type GetCentreGroupByPayload<T extends CentreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CentreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CentreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CentreGroupByOutputType[P]>
            : GetScalarType<T[P], CentreGroupByOutputType[P]>
        }
      >
    >


  export type CentreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_centre?: boolean
    lieu?: boolean
    terrains?: boolean | Centre$terrainsArgs<ExtArgs>
    _count?: boolean | CentreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["centre"]>

  export type CentreSelectScalar = {
    id_centre?: boolean
    lieu?: boolean
  }

  export type CentreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terrains?: boolean | Centre$terrainsArgs<ExtArgs>
    _count?: boolean | CentreCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CentrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Centre"
    objects: {
      terrains: Prisma.$TerrainPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_centre: string
      lieu: string
    }, ExtArgs["result"]["centre"]>
    composites: {}
  }


  type CentreGetPayload<S extends boolean | null | undefined | CentreDefaultArgs> = $Result.GetResult<Prisma.$CentrePayload, S>

  type CentreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CentreFindManyArgs, 'select' | 'include'> & {
      select?: CentreCountAggregateInputType | true
    }

  export interface CentreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Centre'], meta: { name: 'Centre' } }
    /**
     * Find zero or one Centre that matches the filter.
     * @param {CentreFindUniqueArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CentreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CentreFindUniqueArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Centre that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CentreFindUniqueOrThrowArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CentreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Centre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindFirstArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CentreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreFindFirstArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Centre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindFirstOrThrowArgs} args - Arguments to find a Centre
     * @example
     * // Get one Centre
     * const centre = await prisma.centre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CentreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Centres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Centres
     * const centres = await prisma.centre.findMany()
     * 
     * // Get first 10 Centres
     * const centres = await prisma.centre.findMany({ take: 10 })
     * 
     * // Only select the `id_centre`
     * const centreWithId_centreOnly = await prisma.centre.findMany({ select: { id_centre: true } })
     * 
    **/
    findMany<T extends CentreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Centre.
     * @param {CentreCreateArgs} args - Arguments to create a Centre.
     * @example
     * // Create one Centre
     * const Centre = await prisma.centre.create({
     *   data: {
     *     // ... data to create a Centre
     *   }
     * })
     * 
    **/
    create<T extends CentreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CentreCreateArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Centres.
     *     @param {CentreCreateManyArgs} args - Arguments to create many Centres.
     *     @example
     *     // Create many Centres
     *     const centre = await prisma.centre.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CentreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Centre.
     * @param {CentreDeleteArgs} args - Arguments to delete one Centre.
     * @example
     * // Delete one Centre
     * const Centre = await prisma.centre.delete({
     *   where: {
     *     // ... filter to delete one Centre
     *   }
     * })
     * 
    **/
    delete<T extends CentreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CentreDeleteArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Centre.
     * @param {CentreUpdateArgs} args - Arguments to update one Centre.
     * @example
     * // Update one Centre
     * const centre = await prisma.centre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CentreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CentreUpdateArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Centres.
     * @param {CentreDeleteManyArgs} args - Arguments to filter Centres to delete.
     * @example
     * // Delete a few Centres
     * const { count } = await prisma.centre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CentreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CentreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Centres
     * const centre = await prisma.centre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CentreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CentreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Centre.
     * @param {CentreUpsertArgs} args - Arguments to update or create a Centre.
     * @example
     * // Update or create a Centre
     * const centre = await prisma.centre.upsert({
     *   create: {
     *     // ... data to create a Centre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Centre we want to update
     *   }
     * })
    **/
    upsert<T extends CentreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CentreUpsertArgs<ExtArgs>>
    ): Prisma__CentreClient<$Result.GetResult<Prisma.$CentrePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Centres that matches the filter.
     * @param {CentreFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const centre = await prisma.centre.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CentreFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Centre.
     * @param {CentreAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const centre = await prisma.centre.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CentreAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Centres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreCountArgs} args - Arguments to filter Centres to count.
     * @example
     * // Count the number of Centres
     * const count = await prisma.centre.count({
     *   where: {
     *     // ... the filter for the Centres we want to count
     *   }
     * })
    **/
    count<T extends CentreCountArgs>(
      args?: Subset<T, CentreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CentreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CentreAggregateArgs>(args: Subset<T, CentreAggregateArgs>): Prisma.PrismaPromise<GetCentreAggregateType<T>>

    /**
     * Group by Centre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CentreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CentreGroupByArgs['orderBy'] }
        : { orderBy?: CentreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CentreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCentreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Centre model
   */
  readonly fields: CentreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Centre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CentreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    terrains<T extends Centre$terrainsArgs<ExtArgs> = {}>(args?: Subset<T, Centre$terrainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerrainPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Centre model
   */ 
  interface CentreFieldRefs {
    readonly id_centre: FieldRef<"Centre", 'String'>
    readonly lieu: FieldRef<"Centre", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Centre findUnique
   */
  export type CentreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where: CentreWhereUniqueInput
  }


  /**
   * Centre findUniqueOrThrow
   */
  export type CentreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where: CentreWhereUniqueInput
  }


  /**
   * Centre findFirst
   */
  export type CentreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Centres.
     */
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }


  /**
   * Centre findFirstOrThrow
   */
  export type CentreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centre to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Centres.
     */
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }


  /**
   * Centre findMany
   */
  export type CentreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter, which Centres to fetch.
     */
    where?: CentreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Centres to fetch.
     */
    orderBy?: CentreOrderByWithRelationInput | CentreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Centres.
     */
    cursor?: CentreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Centres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Centres.
     */
    skip?: number
    distinct?: CentreScalarFieldEnum | CentreScalarFieldEnum[]
  }


  /**
   * Centre create
   */
  export type CentreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The data needed to create a Centre.
     */
    data: XOR<CentreCreateInput, CentreUncheckedCreateInput>
  }


  /**
   * Centre createMany
   */
  export type CentreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Centres.
     */
    data: CentreCreateManyInput | CentreCreateManyInput[]
  }


  /**
   * Centre update
   */
  export type CentreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The data needed to update a Centre.
     */
    data: XOR<CentreUpdateInput, CentreUncheckedUpdateInput>
    /**
     * Choose, which Centre to update.
     */
    where: CentreWhereUniqueInput
  }


  /**
   * Centre updateMany
   */
  export type CentreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Centres.
     */
    data: XOR<CentreUpdateManyMutationInput, CentreUncheckedUpdateManyInput>
    /**
     * Filter which Centres to update
     */
    where?: CentreWhereInput
  }


  /**
   * Centre upsert
   */
  export type CentreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * The filter to search for the Centre to update in case it exists.
     */
    where: CentreWhereUniqueInput
    /**
     * In case the Centre found by the `where` argument doesn't exist, create a new Centre with this data.
     */
    create: XOR<CentreCreateInput, CentreUncheckedCreateInput>
    /**
     * In case the Centre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CentreUpdateInput, CentreUncheckedUpdateInput>
  }


  /**
   * Centre delete
   */
  export type CentreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
    /**
     * Filter which Centre to delete.
     */
    where: CentreWhereUniqueInput
  }


  /**
   * Centre deleteMany
   */
  export type CentreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Centres to delete
     */
    where?: CentreWhereInput
  }


  /**
   * Centre findRaw
   */
  export type CentreFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Centre aggregateRaw
   */
  export type CentreAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Centre.terrains
   */
  export type Centre$terrainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terrain
     */
    select?: TerrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TerrainInclude<ExtArgs> | null
    where?: TerrainWhereInput
    orderBy?: TerrainOrderByWithRelationInput | TerrainOrderByWithRelationInput[]
    cursor?: TerrainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerrainScalarFieldEnum | TerrainScalarFieldEnum[]
  }


  /**
   * Centre without action
   */
  export type CentreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Centre
     */
    select?: CentreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CentreInclude<ExtArgs> | null
  }



  /**
   * Model Choix
   */

  export type AggregateChoix = {
    _count: ChoixCountAggregateOutputType | null
    _min: ChoixMinAggregateOutputType | null
    _max: ChoixMaxAggregateOutputType | null
  }

  export type ChoixMinAggregateOutputType = {
    id_choix: string | null
    id_candidat: string | null
    id_sport: string | null
  }

  export type ChoixMaxAggregateOutputType = {
    id_choix: string | null
    id_candidat: string | null
    id_sport: string | null
  }

  export type ChoixCountAggregateOutputType = {
    id_choix: number
    id_candidat: number
    id_sport: number
    _all: number
  }


  export type ChoixMinAggregateInputType = {
    id_choix?: true
    id_candidat?: true
    id_sport?: true
  }

  export type ChoixMaxAggregateInputType = {
    id_choix?: true
    id_candidat?: true
    id_sport?: true
  }

  export type ChoixCountAggregateInputType = {
    id_choix?: true
    id_candidat?: true
    id_sport?: true
    _all?: true
  }

  export type ChoixAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choix to aggregate.
     */
    where?: ChoixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choixes to fetch.
     */
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choixes
    **/
    _count?: true | ChoixCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoixMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoixMaxAggregateInputType
  }

  export type GetChoixAggregateType<T extends ChoixAggregateArgs> = {
        [P in keyof T & keyof AggregateChoix]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoix[P]>
      : GetScalarType<T[P], AggregateChoix[P]>
  }




  export type ChoixGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoixWhereInput
    orderBy?: ChoixOrderByWithAggregationInput | ChoixOrderByWithAggregationInput[]
    by: ChoixScalarFieldEnum[] | ChoixScalarFieldEnum
    having?: ChoixScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoixCountAggregateInputType | true
    _min?: ChoixMinAggregateInputType
    _max?: ChoixMaxAggregateInputType
  }

  export type ChoixGroupByOutputType = {
    id_choix: string
    id_candidat: string
    id_sport: string
    _count: ChoixCountAggregateOutputType | null
    _min: ChoixMinAggregateOutputType | null
    _max: ChoixMaxAggregateOutputType | null
  }

  type GetChoixGroupByPayload<T extends ChoixGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoixGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoixGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoixGroupByOutputType[P]>
            : GetScalarType<T[P], ChoixGroupByOutputType[P]>
        }
      >
    >


  export type ChoixSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_choix?: boolean
    id_candidat?: boolean
    id_sport?: boolean
    candidat?: boolean | CandidatDefaultArgs<ExtArgs>
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choix"]>

  export type ChoixSelectScalar = {
    id_choix?: boolean
    id_candidat?: boolean
    id_sport?: boolean
  }

  export type ChoixInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidat?: boolean | CandidatDefaultArgs<ExtArgs>
    sport?: boolean | SportDefaultArgs<ExtArgs>
  }


  export type $ChoixPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Choix"
    objects: {
      candidat: Prisma.$CandidatPayload<ExtArgs>
      sport: Prisma.$SportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_choix: string
      id_candidat: string
      id_sport: string
    }, ExtArgs["result"]["choix"]>
    composites: {}
  }


  type ChoixGetPayload<S extends boolean | null | undefined | ChoixDefaultArgs> = $Result.GetResult<Prisma.$ChoixPayload, S>

  type ChoixCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoixFindManyArgs, 'select' | 'include'> & {
      select?: ChoixCountAggregateInputType | true
    }

  export interface ChoixDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Choix'], meta: { name: 'Choix' } }
    /**
     * Find zero or one Choix that matches the filter.
     * @param {ChoixFindUniqueArgs} args - Arguments to find a Choix
     * @example
     * // Get one Choix
     * const choix = await prisma.choix.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChoixFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixFindUniqueArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Choix that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChoixFindUniqueOrThrowArgs} args - Arguments to find a Choix
     * @example
     * // Get one Choix
     * const choix = await prisma.choix.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChoixFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Choix that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixFindFirstArgs} args - Arguments to find a Choix
     * @example
     * // Get one Choix
     * const choix = await prisma.choix.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChoixFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixFindFirstArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Choix that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixFindFirstOrThrowArgs} args - Arguments to find a Choix
     * @example
     * // Get one Choix
     * const choix = await prisma.choix.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChoixFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Choixes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choixes
     * const choixes = await prisma.choix.findMany()
     * 
     * // Get first 10 Choixes
     * const choixes = await prisma.choix.findMany({ take: 10 })
     * 
     * // Only select the `id_choix`
     * const choixWithId_choixOnly = await prisma.choix.findMany({ select: { id_choix: true } })
     * 
    **/
    findMany<T extends ChoixFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Choix.
     * @param {ChoixCreateArgs} args - Arguments to create a Choix.
     * @example
     * // Create one Choix
     * const Choix = await prisma.choix.create({
     *   data: {
     *     // ... data to create a Choix
     *   }
     * })
     * 
    **/
    create<T extends ChoixCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixCreateArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Choixes.
     *     @param {ChoixCreateManyArgs} args - Arguments to create many Choixes.
     *     @example
     *     // Create many Choixes
     *     const choix = await prisma.choix.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChoixCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choix.
     * @param {ChoixDeleteArgs} args - Arguments to delete one Choix.
     * @example
     * // Delete one Choix
     * const Choix = await prisma.choix.delete({
     *   where: {
     *     // ... filter to delete one Choix
     *   }
     * })
     * 
    **/
    delete<T extends ChoixDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixDeleteArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Choix.
     * @param {ChoixUpdateArgs} args - Arguments to update one Choix.
     * @example
     * // Update one Choix
     * const choix = await prisma.choix.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChoixUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixUpdateArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Choixes.
     * @param {ChoixDeleteManyArgs} args - Arguments to filter Choixes to delete.
     * @example
     * // Delete a few Choixes
     * const { count } = await prisma.choix.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChoixDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChoixDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choixes
     * const choix = await prisma.choix.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChoixUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choix.
     * @param {ChoixUpsertArgs} args - Arguments to update or create a Choix.
     * @example
     * // Update or create a Choix
     * const choix = await prisma.choix.upsert({
     *   create: {
     *     // ... data to create a Choix
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choix we want to update
     *   }
     * })
    **/
    upsert<T extends ChoixUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChoixUpsertArgs<ExtArgs>>
    ): Prisma__ChoixClient<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Choixes that matches the filter.
     * @param {ChoixFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const choix = await prisma.choix.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ChoixFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Choix.
     * @param {ChoixAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const choix = await prisma.choix.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ChoixAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Choixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixCountArgs} args - Arguments to filter Choixes to count.
     * @example
     * // Count the number of Choixes
     * const count = await prisma.choix.count({
     *   where: {
     *     // ... the filter for the Choixes we want to count
     *   }
     * })
    **/
    count<T extends ChoixCountArgs>(
      args?: Subset<T, ChoixCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoixCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoixAggregateArgs>(args: Subset<T, ChoixAggregateArgs>): Prisma.PrismaPromise<GetChoixAggregateType<T>>

    /**
     * Group by Choix.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoixGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoixGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoixGroupByArgs['orderBy'] }
        : { orderBy?: ChoixGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoixGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoixGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Choix model
   */
  readonly fields: ChoixFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Choix.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoixClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    candidat<T extends CandidatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidatDefaultArgs<ExtArgs>>): Prisma__CandidatClient<$Result.GetResult<Prisma.$CandidatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sport<T extends SportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SportDefaultArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Choix model
   */ 
  interface ChoixFieldRefs {
    readonly id_choix: FieldRef<"Choix", 'String'>
    readonly id_candidat: FieldRef<"Choix", 'String'>
    readonly id_sport: FieldRef<"Choix", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Choix findUnique
   */
  export type ChoixFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter, which Choix to fetch.
     */
    where: ChoixWhereUniqueInput
  }


  /**
   * Choix findUniqueOrThrow
   */
  export type ChoixFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter, which Choix to fetch.
     */
    where: ChoixWhereUniqueInput
  }


  /**
   * Choix findFirst
   */
  export type ChoixFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter, which Choix to fetch.
     */
    where?: ChoixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choixes to fetch.
     */
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choixes.
     */
    cursor?: ChoixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choixes.
     */
    distinct?: ChoixScalarFieldEnum | ChoixScalarFieldEnum[]
  }


  /**
   * Choix findFirstOrThrow
   */
  export type ChoixFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter, which Choix to fetch.
     */
    where?: ChoixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choixes to fetch.
     */
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choixes.
     */
    cursor?: ChoixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choixes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choixes.
     */
    distinct?: ChoixScalarFieldEnum | ChoixScalarFieldEnum[]
  }


  /**
   * Choix findMany
   */
  export type ChoixFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter, which Choixes to fetch.
     */
    where?: ChoixWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choixes to fetch.
     */
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choixes.
     */
    cursor?: ChoixWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choixes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choixes.
     */
    skip?: number
    distinct?: ChoixScalarFieldEnum | ChoixScalarFieldEnum[]
  }


  /**
   * Choix create
   */
  export type ChoixCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * The data needed to create a Choix.
     */
    data: XOR<ChoixCreateInput, ChoixUncheckedCreateInput>
  }


  /**
   * Choix createMany
   */
  export type ChoixCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Choixes.
     */
    data: ChoixCreateManyInput | ChoixCreateManyInput[]
  }


  /**
   * Choix update
   */
  export type ChoixUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * The data needed to update a Choix.
     */
    data: XOR<ChoixUpdateInput, ChoixUncheckedUpdateInput>
    /**
     * Choose, which Choix to update.
     */
    where: ChoixWhereUniqueInput
  }


  /**
   * Choix updateMany
   */
  export type ChoixUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Choixes.
     */
    data: XOR<ChoixUpdateManyMutationInput, ChoixUncheckedUpdateManyInput>
    /**
     * Filter which Choixes to update
     */
    where?: ChoixWhereInput
  }


  /**
   * Choix upsert
   */
  export type ChoixUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * The filter to search for the Choix to update in case it exists.
     */
    where: ChoixWhereUniqueInput
    /**
     * In case the Choix found by the `where` argument doesn't exist, create a new Choix with this data.
     */
    create: XOR<ChoixCreateInput, ChoixUncheckedCreateInput>
    /**
     * In case the Choix was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoixUpdateInput, ChoixUncheckedUpdateInput>
  }


  /**
   * Choix delete
   */
  export type ChoixDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    /**
     * Filter which Choix to delete.
     */
    where: ChoixWhereUniqueInput
  }


  /**
   * Choix deleteMany
   */
  export type ChoixDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choixes to delete
     */
    where?: ChoixWhereInput
  }


  /**
   * Choix findRaw
   */
  export type ChoixFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Choix aggregateRaw
   */
  export type ChoixAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Choix without action
   */
  export type ChoixDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
  }



  /**
   * Model Sport
   */

  export type AggregateSport = {
    _count: SportCountAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  export type SportMinAggregateOutputType = {
    id_sport: string | null
    nom_sport: string | null
    type: $Enums.TYPE_SPORT | null
  }

  export type SportMaxAggregateOutputType = {
    id_sport: string | null
    nom_sport: string | null
    type: $Enums.TYPE_SPORT | null
  }

  export type SportCountAggregateOutputType = {
    id_sport: number
    nom_sport: number
    type: number
    _all: number
  }


  export type SportMinAggregateInputType = {
    id_sport?: true
    nom_sport?: true
    type?: true
  }

  export type SportMaxAggregateInputType = {
    id_sport?: true
    nom_sport?: true
    type?: true
  }

  export type SportCountAggregateInputType = {
    id_sport?: true
    nom_sport?: true
    type?: true
    _all?: true
  }

  export type SportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sport to aggregate.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sports
    **/
    _count?: true | SportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportMaxAggregateInputType
  }

  export type GetSportAggregateType<T extends SportAggregateArgs> = {
        [P in keyof T & keyof AggregateSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSport[P]>
      : GetScalarType<T[P], AggregateSport[P]>
  }




  export type SportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportWhereInput
    orderBy?: SportOrderByWithAggregationInput | SportOrderByWithAggregationInput[]
    by: SportScalarFieldEnum[] | SportScalarFieldEnum
    having?: SportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportCountAggregateInputType | true
    _min?: SportMinAggregateInputType
    _max?: SportMaxAggregateInputType
  }

  export type SportGroupByOutputType = {
    id_sport: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
    _count: SportCountAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  type GetSportGroupByPayload<T extends SportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportGroupByOutputType[P]>
            : GetScalarType<T[P], SportGroupByOutputType[P]>
        }
      >
    >


  export type SportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_sport?: boolean
    nom_sport?: boolean
    type?: boolean
    choix?: boolean | Sport$choixArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectScalar = {
    id_sport?: boolean
    nom_sport?: boolean
    type?: boolean
  }

  export type SportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    choix?: boolean | Sport$choixArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sport"
    objects: {
      choix: Prisma.$ChoixPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_sport: string
      nom_sport: string
      type: $Enums.TYPE_SPORT
    }, ExtArgs["result"]["sport"]>
    composites: {}
  }


  type SportGetPayload<S extends boolean | null | undefined | SportDefaultArgs> = $Result.GetResult<Prisma.$SportPayload, S>

  type SportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SportFindManyArgs, 'select' | 'include'> & {
      select?: SportCountAggregateInputType | true
    }

  export interface SportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sport'], meta: { name: 'Sport' } }
    /**
     * Find zero or one Sport that matches the filter.
     * @param {SportFindUniqueArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SportFindUniqueArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SportFindUniqueOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SportFindFirstArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sports
     * const sports = await prisma.sport.findMany()
     * 
     * // Get first 10 Sports
     * const sports = await prisma.sport.findMany({ take: 10 })
     * 
     * // Only select the `id_sport`
     * const sportWithId_sportOnly = await prisma.sport.findMany({ select: { id_sport: true } })
     * 
    **/
    findMany<T extends SportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sport.
     * @param {SportCreateArgs} args - Arguments to create a Sport.
     * @example
     * // Create one Sport
     * const Sport = await prisma.sport.create({
     *   data: {
     *     // ... data to create a Sport
     *   }
     * })
     * 
    **/
    create<T extends SportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SportCreateArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sports.
     *     @param {SportCreateManyArgs} args - Arguments to create many Sports.
     *     @example
     *     // Create many Sports
     *     const sport = await prisma.sport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sport.
     * @param {SportDeleteArgs} args - Arguments to delete one Sport.
     * @example
     * // Delete one Sport
     * const Sport = await prisma.sport.delete({
     *   where: {
     *     // ... filter to delete one Sport
     *   }
     * })
     * 
    **/
    delete<T extends SportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SportDeleteArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sport.
     * @param {SportUpdateArgs} args - Arguments to update one Sport.
     * @example
     * // Update one Sport
     * const sport = await prisma.sport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SportUpdateArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sports.
     * @param {SportDeleteManyArgs} args - Arguments to filter Sports to delete.
     * @example
     * // Delete a few Sports
     * const { count } = await prisma.sport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sport.
     * @param {SportUpsertArgs} args - Arguments to update or create a Sport.
     * @example
     * // Update or create a Sport
     * const sport = await prisma.sport.upsert({
     *   create: {
     *     // ... data to create a Sport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sport we want to update
     *   }
     * })
    **/
    upsert<T extends SportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SportUpsertArgs<ExtArgs>>
    ): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Sports that matches the filter.
     * @param {SportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sport = await prisma.sport.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SportFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sport.
     * @param {SportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sport = await prisma.sport.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SportAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCountArgs} args - Arguments to filter Sports to count.
     * @example
     * // Count the number of Sports
     * const count = await prisma.sport.count({
     *   where: {
     *     // ... the filter for the Sports we want to count
     *   }
     * })
    **/
    count<T extends SportCountArgs>(
      args?: Subset<T, SportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportAggregateArgs>(args: Subset<T, SportAggregateArgs>): Prisma.PrismaPromise<GetSportAggregateType<T>>

    /**
     * Group by Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportGroupByArgs['orderBy'] }
        : { orderBy?: SportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sport model
   */
  readonly fields: SportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    choix<T extends Sport$choixArgs<ExtArgs> = {}>(args?: Subset<T, Sport$choixArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoixPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sport model
   */ 
  interface SportFieldRefs {
    readonly id_sport: FieldRef<"Sport", 'String'>
    readonly nom_sport: FieldRef<"Sport", 'String'>
    readonly type: FieldRef<"Sport", 'TYPE_SPORT'>
  }
    

  // Custom InputTypes

  /**
   * Sport findUnique
   */
  export type SportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }


  /**
   * Sport findUniqueOrThrow
   */
  export type SportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }


  /**
   * Sport findFirst
   */
  export type SportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }


  /**
   * Sport findFirstOrThrow
   */
  export type SportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }


  /**
   * Sport findMany
   */
  export type SportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sports to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }


  /**
   * Sport create
   */
  export type SportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to create a Sport.
     */
    data: XOR<SportCreateInput, SportUncheckedCreateInput>
  }


  /**
   * Sport createMany
   */
  export type SportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
  }


  /**
   * Sport update
   */
  export type SportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to update a Sport.
     */
    data: XOR<SportUpdateInput, SportUncheckedUpdateInput>
    /**
     * Choose, which Sport to update.
     */
    where: SportWhereUniqueInput
  }


  /**
   * Sport updateMany
   */
  export type SportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
  }


  /**
   * Sport upsert
   */
  export type SportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The filter to search for the Sport to update in case it exists.
     */
    where: SportWhereUniqueInput
    /**
     * In case the Sport found by the `where` argument doesn't exist, create a new Sport with this data.
     */
    create: XOR<SportCreateInput, SportUncheckedCreateInput>
    /**
     * In case the Sport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportUpdateInput, SportUncheckedUpdateInput>
  }


  /**
   * Sport delete
   */
  export type SportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter which Sport to delete.
     */
    where: SportWhereUniqueInput
  }


  /**
   * Sport deleteMany
   */
  export type SportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sports to delete
     */
    where?: SportWhereInput
  }


  /**
   * Sport findRaw
   */
  export type SportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Sport aggregateRaw
   */
  export type SportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Sport.choix
   */
  export type Sport$choixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choix
     */
    select?: ChoixSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChoixInclude<ExtArgs> | null
    where?: ChoixWhereInput
    orderBy?: ChoixOrderByWithRelationInput | ChoixOrderByWithRelationInput[]
    cursor?: ChoixWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoixScalarFieldEnum | ChoixScalarFieldEnum[]
  }


  /**
   * Sport without action
   */
  export type SportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SportInclude<ExtArgs> | null
  }



  /**
   * Model Utilisateur
   */

  export type AggregateUtilisateur = {
    _count: UtilisateurCountAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  export type UtilisateurMinAggregateOutputType = {
    id_utilisateur: string | null
    nom_complet: string | null
    password: string | null
    email: string | null
  }

  export type UtilisateurMaxAggregateOutputType = {
    id_utilisateur: string | null
    nom_complet: string | null
    password: string | null
    email: string | null
  }

  export type UtilisateurCountAggregateOutputType = {
    id_utilisateur: number
    nom_complet: number
    password: number
    email: number
    _all: number
  }


  export type UtilisateurMinAggregateInputType = {
    id_utilisateur?: true
    nom_complet?: true
    password?: true
    email?: true
  }

  export type UtilisateurMaxAggregateInputType = {
    id_utilisateur?: true
    nom_complet?: true
    password?: true
    email?: true
  }

  export type UtilisateurCountAggregateInputType = {
    id_utilisateur?: true
    nom_complet?: true
    password?: true
    email?: true
    _all?: true
  }

  export type UtilisateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateur to aggregate.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utilisateurs
    **/
    _count?: true | UtilisateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateurMaxAggregateInputType
  }

  export type GetUtilisateurAggregateType<T extends UtilisateurAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateur[P]>
      : GetScalarType<T[P], AggregateUtilisateur[P]>
  }




  export type UtilisateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithAggregationInput | UtilisateurOrderByWithAggregationInput[]
    by: UtilisateurScalarFieldEnum[] | UtilisateurScalarFieldEnum
    having?: UtilisateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateurCountAggregateInputType | true
    _min?: UtilisateurMinAggregateInputType
    _max?: UtilisateurMaxAggregateInputType
  }

  export type UtilisateurGroupByOutputType = {
    id_utilisateur: string
    nom_complet: string
    password: string
    email: string
    _count: UtilisateurCountAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  type GetUtilisateurGroupByPayload<T extends UtilisateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
        }
      >
    >


  export type UtilisateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_utilisateur?: boolean
    nom_complet?: boolean
    password?: boolean
    email?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectScalar = {
    id_utilisateur?: boolean
    nom_complet?: boolean
    password?: boolean
    email?: boolean
  }


  export type $UtilisateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utilisateur"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_utilisateur: string
      nom_complet: string
      password: string
      email: string
    }, ExtArgs["result"]["utilisateur"]>
    composites: {}
  }


  type UtilisateurGetPayload<S extends boolean | null | undefined | UtilisateurDefaultArgs> = $Result.GetResult<Prisma.$UtilisateurPayload, S>

  type UtilisateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UtilisateurFindManyArgs, 'select' | 'include'> & {
      select?: UtilisateurCountAggregateInputType | true
    }

  export interface UtilisateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utilisateur'], meta: { name: 'Utilisateur' } }
    /**
     * Find zero or one Utilisateur that matches the filter.
     * @param {UtilisateurFindUniqueArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UtilisateurFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurFindUniqueArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Utilisateur that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UtilisateurFindUniqueOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UtilisateurFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Utilisateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UtilisateurFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindFirstArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Utilisateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UtilisateurFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany({ take: 10 })
     * 
     * // Only select the `id_utilisateur`
     * const utilisateurWithId_utilisateurOnly = await prisma.utilisateur.findMany({ select: { id_utilisateur: true } })
     * 
    **/
    findMany<T extends UtilisateurFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Utilisateur.
     * @param {UtilisateurCreateArgs} args - Arguments to create a Utilisateur.
     * @example
     * // Create one Utilisateur
     * const Utilisateur = await prisma.utilisateur.create({
     *   data: {
     *     // ... data to create a Utilisateur
     *   }
     * })
     * 
    **/
    create<T extends UtilisateurCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurCreateArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Utilisateurs.
     *     @param {UtilisateurCreateManyArgs} args - Arguments to create many Utilisateurs.
     *     @example
     *     // Create many Utilisateurs
     *     const utilisateur = await prisma.utilisateur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UtilisateurCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utilisateur.
     * @param {UtilisateurDeleteArgs} args - Arguments to delete one Utilisateur.
     * @example
     * // Delete one Utilisateur
     * const Utilisateur = await prisma.utilisateur.delete({
     *   where: {
     *     // ... filter to delete one Utilisateur
     *   }
     * })
     * 
    **/
    delete<T extends UtilisateurDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurDeleteArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Utilisateur.
     * @param {UtilisateurUpdateArgs} args - Arguments to update one Utilisateur.
     * @example
     * // Update one Utilisateur
     * const utilisateur = await prisma.utilisateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UtilisateurUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpdateArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Utilisateurs.
     * @param {UtilisateurDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UtilisateurDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtilisateurDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UtilisateurUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utilisateur.
     * @param {UtilisateurUpsertArgs} args - Arguments to update or create a Utilisateur.
     * @example
     * // Update or create a Utilisateur
     * const utilisateur = await prisma.utilisateur.upsert({
     *   create: {
     *     // ... data to create a Utilisateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateur we want to update
     *   }
     * })
    **/
    upsert<T extends UtilisateurUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UtilisateurUpsertArgs<ExtArgs>>
    ): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * @param {UtilisateurFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const utilisateur = await prisma.utilisateur.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UtilisateurFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Utilisateur.
     * @param {UtilisateurAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const utilisateur = await prisma.utilisateur.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UtilisateurAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateur.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends UtilisateurCountArgs>(
      args?: Subset<T, UtilisateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateurAggregateArgs>(args: Subset<T, UtilisateurAggregateArgs>): Prisma.PrismaPromise<GetUtilisateurAggregateType<T>>

    /**
     * Group by Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilisateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilisateurGroupByArgs['orderBy'] }
        : { orderBy?: UtilisateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilisateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utilisateur model
   */
  readonly fields: UtilisateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utilisateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilisateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Utilisateur model
   */ 
  interface UtilisateurFieldRefs {
    readonly id_utilisateur: FieldRef<"Utilisateur", 'String'>
    readonly nom_complet: FieldRef<"Utilisateur", 'String'>
    readonly password: FieldRef<"Utilisateur", 'String'>
    readonly email: FieldRef<"Utilisateur", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Utilisateur findUnique
   */
  export type UtilisateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur findUniqueOrThrow
   */
  export type UtilisateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur findFirst
   */
  export type UtilisateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur findFirstOrThrow
   */
  export type UtilisateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur findMany
   */
  export type UtilisateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter, which Utilisateurs to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }


  /**
   * Utilisateur create
   */
  export type UtilisateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * The data needed to create a Utilisateur.
     */
    data: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
  }


  /**
   * Utilisateur createMany
   */
  export type UtilisateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
  }


  /**
   * Utilisateur update
   */
  export type UtilisateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * The data needed to update a Utilisateur.
     */
    data: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
    /**
     * Choose, which Utilisateur to update.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur updateMany
   */
  export type UtilisateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
  }


  /**
   * Utilisateur upsert
   */
  export type UtilisateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * The filter to search for the Utilisateur to update in case it exists.
     */
    where: UtilisateurWhereUniqueInput
    /**
     * In case the Utilisateur found by the `where` argument doesn't exist, create a new Utilisateur with this data.
     */
    create: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
    /**
     * In case the Utilisateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
  }


  /**
   * Utilisateur delete
   */
  export type UtilisateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Filter which Utilisateur to delete.
     */
    where: UtilisateurWhereUniqueInput
  }


  /**
   * Utilisateur deleteMany
   */
  export type UtilisateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateurs to delete
     */
    where?: UtilisateurWhereInput
  }


  /**
   * Utilisateur findRaw
   */
  export type UtilisateurFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Utilisateur aggregateRaw
   */
  export type UtilisateurAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Utilisateur without action
   */
  export type UtilisateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const CandidatScalarFieldEnum: {
    id_candidat: 'id_candidat',
    numeroInscription: 'numeroInscription',
    nom: 'nom',
    prenoms: 'prenoms',
    date_naissance: 'date_naissance',
    sexe: 'sexe',
    isApte: 'isApte'
  };

  export type CandidatScalarFieldEnum = (typeof CandidatScalarFieldEnum)[keyof typeof CandidatScalarFieldEnum]


  export const GroupeScalarFieldEnum: {
    id_groupe: 'id_groupe',
    numero: 'numero',
    date_epreuve: 'date_epreuve',
    temps: 'temps',
    heure: 'heure',
    id_examinateur: 'id_examinateur',
    terrainId: 'terrainId'
  };

  export type GroupeScalarFieldEnum = (typeof GroupeScalarFieldEnum)[keyof typeof GroupeScalarFieldEnum]


  export const ExaminateurScalarFieldEnum: {
    id_examinateur: 'id_examinateur',
    nom_examinateur: 'nom_examinateur'
  };

  export type ExaminateurScalarFieldEnum = (typeof ExaminateurScalarFieldEnum)[keyof typeof ExaminateurScalarFieldEnum]


  export const TerrainScalarFieldEnum: {
    id_terrain: 'id_terrain',
    nom_terrain: 'nom_terrain',
    id_centre: 'id_centre'
  };

  export type TerrainScalarFieldEnum = (typeof TerrainScalarFieldEnum)[keyof typeof TerrainScalarFieldEnum]


  export const CentreScalarFieldEnum: {
    id_centre: 'id_centre',
    lieu: 'lieu'
  };

  export type CentreScalarFieldEnum = (typeof CentreScalarFieldEnum)[keyof typeof CentreScalarFieldEnum]


  export const ChoixScalarFieldEnum: {
    id_choix: 'id_choix',
    id_candidat: 'id_candidat',
    id_sport: 'id_sport'
  };

  export type ChoixScalarFieldEnum = (typeof ChoixScalarFieldEnum)[keyof typeof ChoixScalarFieldEnum]


  export const SportScalarFieldEnum: {
    id_sport: 'id_sport',
    nom_sport: 'nom_sport',
    type: 'type'
  };

  export type SportScalarFieldEnum = (typeof SportScalarFieldEnum)[keyof typeof SportScalarFieldEnum]


  export const UtilisateurScalarFieldEnum: {
    id_utilisateur: 'id_utilisateur',
    nom_complet: 'nom_complet',
    password: 'password',
    email: 'email'
  };

  export type UtilisateurScalarFieldEnum = (typeof UtilisateurScalarFieldEnum)[keyof typeof UtilisateurScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SEXE'
   */
  export type EnumSEXEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEXE'>
    


  /**
   * Reference to a field of type 'SEXE[]'
   */
  export type ListEnumSEXEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SEXE[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TEMPS'
   */
  export type EnumTEMPSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TEMPS'>
    


  /**
   * Reference to a field of type 'TEMPS[]'
   */
  export type ListEnumTEMPSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TEMPS[]'>
    


  /**
   * Reference to a field of type 'TYPE_SPORT'
   */
  export type EnumTYPE_SPORTFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TYPE_SPORT'>
    


  /**
   * Reference to a field of type 'TYPE_SPORT[]'
   */
  export type ListEnumTYPE_SPORTFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TYPE_SPORT[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CandidatWhereInput = {
    AND?: CandidatWhereInput | CandidatWhereInput[]
    OR?: CandidatWhereInput[]
    NOT?: CandidatWhereInput | CandidatWhereInput[]
    id_candidat?: StringFilter<"Candidat"> | string
    numeroInscription?: IntFilter<"Candidat"> | number
    nom?: StringFilter<"Candidat"> | string
    prenoms?: StringNullableFilter<"Candidat"> | string | null
    date_naissance?: DateTimeFilter<"Candidat"> | Date | string
    sexe?: EnumSEXEFilter<"Candidat"> | $Enums.SEXE
    isApte?: BoolFilter<"Candidat"> | boolean
    choix?: ChoixListRelationFilter
  }

  export type CandidatOrderByWithRelationInput = {
    id_candidat?: SortOrder
    numeroInscription?: SortOrder
    nom?: SortOrder
    prenoms?: SortOrder
    date_naissance?: SortOrder
    sexe?: SortOrder
    isApte?: SortOrder
    choix?: ChoixOrderByRelationAggregateInput
  }

  export type CandidatWhereUniqueInput = Prisma.AtLeast<{
    id_candidat?: string
    numeroInscription?: number
    AND?: CandidatWhereInput | CandidatWhereInput[]
    OR?: CandidatWhereInput[]
    NOT?: CandidatWhereInput | CandidatWhereInput[]
    nom?: StringFilter<"Candidat"> | string
    prenoms?: StringNullableFilter<"Candidat"> | string | null
    date_naissance?: DateTimeFilter<"Candidat"> | Date | string
    sexe?: EnumSEXEFilter<"Candidat"> | $Enums.SEXE
    isApte?: BoolFilter<"Candidat"> | boolean
    choix?: ChoixListRelationFilter
  }, "id_candidat" | "numeroInscription">

  export type CandidatOrderByWithAggregationInput = {
    id_candidat?: SortOrder
    numeroInscription?: SortOrder
    nom?: SortOrder
    prenoms?: SortOrder
    date_naissance?: SortOrder
    sexe?: SortOrder
    isApte?: SortOrder
    _count?: CandidatCountOrderByAggregateInput
    _avg?: CandidatAvgOrderByAggregateInput
    _max?: CandidatMaxOrderByAggregateInput
    _min?: CandidatMinOrderByAggregateInput
    _sum?: CandidatSumOrderByAggregateInput
  }

  export type CandidatScalarWhereWithAggregatesInput = {
    AND?: CandidatScalarWhereWithAggregatesInput | CandidatScalarWhereWithAggregatesInput[]
    OR?: CandidatScalarWhereWithAggregatesInput[]
    NOT?: CandidatScalarWhereWithAggregatesInput | CandidatScalarWhereWithAggregatesInput[]
    id_candidat?: StringWithAggregatesFilter<"Candidat"> | string
    numeroInscription?: IntWithAggregatesFilter<"Candidat"> | number
    nom?: StringWithAggregatesFilter<"Candidat"> | string
    prenoms?: StringNullableWithAggregatesFilter<"Candidat"> | string | null
    date_naissance?: DateTimeWithAggregatesFilter<"Candidat"> | Date | string
    sexe?: EnumSEXEWithAggregatesFilter<"Candidat"> | $Enums.SEXE
    isApte?: BoolWithAggregatesFilter<"Candidat"> | boolean
  }

  export type GroupeWhereInput = {
    AND?: GroupeWhereInput | GroupeWhereInput[]
    OR?: GroupeWhereInput[]
    NOT?: GroupeWhereInput | GroupeWhereInput[]
    id_groupe?: StringFilter<"Groupe"> | string
    numero?: IntFilter<"Groupe"> | number
    date_epreuve?: DateTimeFilter<"Groupe"> | Date | string
    temps?: EnumTEMPSFilter<"Groupe"> | $Enums.TEMPS
    heure?: StringFilter<"Groupe"> | string
    id_examinateur?: StringFilter<"Groupe"> | string
    terrainId?: StringFilter<"Groupe"> | string
    examinateur?: XOR<ExaminateurRelationFilter, ExaminateurWhereInput>
    terrain?: XOR<TerrainRelationFilter, TerrainWhereInput>
  }

  export type GroupeOrderByWithRelationInput = {
    id_groupe?: SortOrder
    numero?: SortOrder
    date_epreuve?: SortOrder
    temps?: SortOrder
    heure?: SortOrder
    id_examinateur?: SortOrder
    terrainId?: SortOrder
    examinateur?: ExaminateurOrderByWithRelationInput
    terrain?: TerrainOrderByWithRelationInput
  }

  export type GroupeWhereUniqueInput = Prisma.AtLeast<{
    id_groupe?: string
    AND?: GroupeWhereInput | GroupeWhereInput[]
    OR?: GroupeWhereInput[]
    NOT?: GroupeWhereInput | GroupeWhereInput[]
    numero?: IntFilter<"Groupe"> | number
    date_epreuve?: DateTimeFilter<"Groupe"> | Date | string
    temps?: EnumTEMPSFilter<"Groupe"> | $Enums.TEMPS
    heure?: StringFilter<"Groupe"> | string
    id_examinateur?: StringFilter<"Groupe"> | string
    terrainId?: StringFilter<"Groupe"> | string
    examinateur?: XOR<ExaminateurRelationFilter, ExaminateurWhereInput>
    terrain?: XOR<TerrainRelationFilter, TerrainWhereInput>
  }, "id_groupe">

  export type GroupeOrderByWithAggregationInput = {
    id_groupe?: SortOrder
    numero?: SortOrder
    date_epreuve?: SortOrder
    temps?: SortOrder
    heure?: SortOrder
    id_examinateur?: SortOrder
    terrainId?: SortOrder
    _count?: GroupeCountOrderByAggregateInput
    _avg?: GroupeAvgOrderByAggregateInput
    _max?: GroupeMaxOrderByAggregateInput
    _min?: GroupeMinOrderByAggregateInput
    _sum?: GroupeSumOrderByAggregateInput
  }

  export type GroupeScalarWhereWithAggregatesInput = {
    AND?: GroupeScalarWhereWithAggregatesInput | GroupeScalarWhereWithAggregatesInput[]
    OR?: GroupeScalarWhereWithAggregatesInput[]
    NOT?: GroupeScalarWhereWithAggregatesInput | GroupeScalarWhereWithAggregatesInput[]
    id_groupe?: StringWithAggregatesFilter<"Groupe"> | string
    numero?: IntWithAggregatesFilter<"Groupe"> | number
    date_epreuve?: DateTimeWithAggregatesFilter<"Groupe"> | Date | string
    temps?: EnumTEMPSWithAggregatesFilter<"Groupe"> | $Enums.TEMPS
    heure?: StringWithAggregatesFilter<"Groupe"> | string
    id_examinateur?: StringWithAggregatesFilter<"Groupe"> | string
    terrainId?: StringWithAggregatesFilter<"Groupe"> | string
  }

  export type ExaminateurWhereInput = {
    AND?: ExaminateurWhereInput | ExaminateurWhereInput[]
    OR?: ExaminateurWhereInput[]
    NOT?: ExaminateurWhereInput | ExaminateurWhereInput[]
    id_examinateur?: StringFilter<"Examinateur"> | string
    nom_examinateur?: StringFilter<"Examinateur"> | string
    groupes?: GroupeListRelationFilter
  }

  export type ExaminateurOrderByWithRelationInput = {
    id_examinateur?: SortOrder
    nom_examinateur?: SortOrder
    groupes?: GroupeOrderByRelationAggregateInput
  }

  export type ExaminateurWhereUniqueInput = Prisma.AtLeast<{
    id_examinateur?: string
    AND?: ExaminateurWhereInput | ExaminateurWhereInput[]
    OR?: ExaminateurWhereInput[]
    NOT?: ExaminateurWhereInput | ExaminateurWhereInput[]
    nom_examinateur?: StringFilter<"Examinateur"> | string
    groupes?: GroupeListRelationFilter
  }, "id_examinateur">

  export type ExaminateurOrderByWithAggregationInput = {
    id_examinateur?: SortOrder
    nom_examinateur?: SortOrder
    _count?: ExaminateurCountOrderByAggregateInput
    _max?: ExaminateurMaxOrderByAggregateInput
    _min?: ExaminateurMinOrderByAggregateInput
  }

  export type ExaminateurScalarWhereWithAggregatesInput = {
    AND?: ExaminateurScalarWhereWithAggregatesInput | ExaminateurScalarWhereWithAggregatesInput[]
    OR?: ExaminateurScalarWhereWithAggregatesInput[]
    NOT?: ExaminateurScalarWhereWithAggregatesInput | ExaminateurScalarWhereWithAggregatesInput[]
    id_examinateur?: StringWithAggregatesFilter<"Examinateur"> | string
    nom_examinateur?: StringWithAggregatesFilter<"Examinateur"> | string
  }

  export type TerrainWhereInput = {
    AND?: TerrainWhereInput | TerrainWhereInput[]
    OR?: TerrainWhereInput[]
    NOT?: TerrainWhereInput | TerrainWhereInput[]
    id_terrain?: StringFilter<"Terrain"> | string
    nom_terrain?: StringFilter<"Terrain"> | string
    id_centre?: StringFilter<"Terrain"> | string
    centre?: XOR<CentreRelationFilter, CentreWhereInput>
    groupes?: GroupeListRelationFilter
  }

  export type TerrainOrderByWithRelationInput = {
    id_terrain?: SortOrder
    nom_terrain?: SortOrder
    id_centre?: SortOrder
    centre?: CentreOrderByWithRelationInput
    groupes?: GroupeOrderByRelationAggregateInput
  }

  export type TerrainWhereUniqueInput = Prisma.AtLeast<{
    id_terrain?: string
    AND?: TerrainWhereInput | TerrainWhereInput[]
    OR?: TerrainWhereInput[]
    NOT?: TerrainWhereInput | TerrainWhereInput[]
    nom_terrain?: StringFilter<"Terrain"> | string
    id_centre?: StringFilter<"Terrain"> | string
    centre?: XOR<CentreRelationFilter, CentreWhereInput>
    groupes?: GroupeListRelationFilter
  }, "id_terrain">

  export type TerrainOrderByWithAggregationInput = {
    id_terrain?: SortOrder
    nom_terrain?: SortOrder
    id_centre?: SortOrder
    _count?: TerrainCountOrderByAggregateInput
    _max?: TerrainMaxOrderByAggregateInput
    _min?: TerrainMinOrderByAggregateInput
  }

  export type TerrainScalarWhereWithAggregatesInput = {
    AND?: TerrainScalarWhereWithAggregatesInput | TerrainScalarWhereWithAggregatesInput[]
    OR?: TerrainScalarWhereWithAggregatesInput[]
    NOT?: TerrainScalarWhereWithAggregatesInput | TerrainScalarWhereWithAggregatesInput[]
    id_terrain?: StringWithAggregatesFilter<"Terrain"> | string
    nom_terrain?: StringWithAggregatesFilter<"Terrain"> | string
    id_centre?: StringWithAggregatesFilter<"Terrain"> | string
  }

  export type CentreWhereInput = {
    AND?: CentreWhereInput | CentreWhereInput[]
    OR?: CentreWhereInput[]
    NOT?: CentreWhereInput | CentreWhereInput[]
    id_centre?: StringFilter<"Centre"> | string
    lieu?: StringFilter<"Centre"> | string
    terrains?: TerrainListRelationFilter
  }

  export type CentreOrderByWithRelationInput = {
    id_centre?: SortOrder
    lieu?: SortOrder
    terrains?: TerrainOrderByRelationAggregateInput
  }

  export type CentreWhereUniqueInput = Prisma.AtLeast<{
    id_centre?: string
    AND?: CentreWhereInput | CentreWhereInput[]
    OR?: CentreWhereInput[]
    NOT?: CentreWhereInput | CentreWhereInput[]
    lieu?: StringFilter<"Centre"> | string
    terrains?: TerrainListRelationFilter
  }, "id_centre">

  export type CentreOrderByWithAggregationInput = {
    id_centre?: SortOrder
    lieu?: SortOrder
    _count?: CentreCountOrderByAggregateInput
    _max?: CentreMaxOrderByAggregateInput
    _min?: CentreMinOrderByAggregateInput
  }

  export type CentreScalarWhereWithAggregatesInput = {
    AND?: CentreScalarWhereWithAggregatesInput | CentreScalarWhereWithAggregatesInput[]
    OR?: CentreScalarWhereWithAggregatesInput[]
    NOT?: CentreScalarWhereWithAggregatesInput | CentreScalarWhereWithAggregatesInput[]
    id_centre?: StringWithAggregatesFilter<"Centre"> | string
    lieu?: StringWithAggregatesFilter<"Centre"> | string
  }

  export type ChoixWhereInput = {
    AND?: ChoixWhereInput | ChoixWhereInput[]
    OR?: ChoixWhereInput[]
    NOT?: ChoixWhereInput | ChoixWhereInput[]
    id_choix?: StringFilter<"Choix"> | string
    id_candidat?: StringFilter<"Choix"> | string
    id_sport?: StringFilter<"Choix"> | string
    candidat?: XOR<CandidatRelationFilter, CandidatWhereInput>
    sport?: XOR<SportRelationFilter, SportWhereInput>
  }

  export type ChoixOrderByWithRelationInput = {
    id_choix?: SortOrder
    id_candidat?: SortOrder
    id_sport?: SortOrder
    candidat?: CandidatOrderByWithRelationInput
    sport?: SportOrderByWithRelationInput
  }

  export type ChoixWhereUniqueInput = Prisma.AtLeast<{
    id_choix?: string
    AND?: ChoixWhereInput | ChoixWhereInput[]
    OR?: ChoixWhereInput[]
    NOT?: ChoixWhereInput | ChoixWhereInput[]
    id_candidat?: StringFilter<"Choix"> | string
    id_sport?: StringFilter<"Choix"> | string
    candidat?: XOR<CandidatRelationFilter, CandidatWhereInput>
    sport?: XOR<SportRelationFilter, SportWhereInput>
  }, "id_choix">

  export type ChoixOrderByWithAggregationInput = {
    id_choix?: SortOrder
    id_candidat?: SortOrder
    id_sport?: SortOrder
    _count?: ChoixCountOrderByAggregateInput
    _max?: ChoixMaxOrderByAggregateInput
    _min?: ChoixMinOrderByAggregateInput
  }

  export type ChoixScalarWhereWithAggregatesInput = {
    AND?: ChoixScalarWhereWithAggregatesInput | ChoixScalarWhereWithAggregatesInput[]
    OR?: ChoixScalarWhereWithAggregatesInput[]
    NOT?: ChoixScalarWhereWithAggregatesInput | ChoixScalarWhereWithAggregatesInput[]
    id_choix?: StringWithAggregatesFilter<"Choix"> | string
    id_candidat?: StringWithAggregatesFilter<"Choix"> | string
    id_sport?: StringWithAggregatesFilter<"Choix"> | string
  }

  export type SportWhereInput = {
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    id_sport?: StringFilter<"Sport"> | string
    nom_sport?: StringFilter<"Sport"> | string
    type?: EnumTYPE_SPORTFilter<"Sport"> | $Enums.TYPE_SPORT
    choix?: ChoixListRelationFilter
  }

  export type SportOrderByWithRelationInput = {
    id_sport?: SortOrder
    nom_sport?: SortOrder
    type?: SortOrder
    choix?: ChoixOrderByRelationAggregateInput
  }

  export type SportWhereUniqueInput = Prisma.AtLeast<{
    id_sport?: string
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    nom_sport?: StringFilter<"Sport"> | string
    type?: EnumTYPE_SPORTFilter<"Sport"> | $Enums.TYPE_SPORT
    choix?: ChoixListRelationFilter
  }, "id_sport">

  export type SportOrderByWithAggregationInput = {
    id_sport?: SortOrder
    nom_sport?: SortOrder
    type?: SortOrder
    _count?: SportCountOrderByAggregateInput
    _max?: SportMaxOrderByAggregateInput
    _min?: SportMinOrderByAggregateInput
  }

  export type SportScalarWhereWithAggregatesInput = {
    AND?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    OR?: SportScalarWhereWithAggregatesInput[]
    NOT?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    id_sport?: StringWithAggregatesFilter<"Sport"> | string
    nom_sport?: StringWithAggregatesFilter<"Sport"> | string
    type?: EnumTYPE_SPORTWithAggregatesFilter<"Sport"> | $Enums.TYPE_SPORT
  }

  export type UtilisateurWhereInput = {
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    id_utilisateur?: StringFilter<"Utilisateur"> | string
    nom_complet?: StringFilter<"Utilisateur"> | string
    password?: StringFilter<"Utilisateur"> | string
    email?: StringFilter<"Utilisateur"> | string
  }

  export type UtilisateurOrderByWithRelationInput = {
    id_utilisateur?: SortOrder
    nom_complet?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type UtilisateurWhereUniqueInput = Prisma.AtLeast<{
    id_utilisateur?: string
    email?: string
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    nom_complet?: StringFilter<"Utilisateur"> | string
    password?: StringFilter<"Utilisateur"> | string
  }, "id_utilisateur" | "email">

  export type UtilisateurOrderByWithAggregationInput = {
    id_utilisateur?: SortOrder
    nom_complet?: SortOrder
    password?: SortOrder
    email?: SortOrder
    _count?: UtilisateurCountOrderByAggregateInput
    _max?: UtilisateurMaxOrderByAggregateInput
    _min?: UtilisateurMinOrderByAggregateInput
  }

  export type UtilisateurScalarWhereWithAggregatesInput = {
    AND?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    OR?: UtilisateurScalarWhereWithAggregatesInput[]
    NOT?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    id_utilisateur?: StringWithAggregatesFilter<"Utilisateur"> | string
    nom_complet?: StringWithAggregatesFilter<"Utilisateur"> | string
    password?: StringWithAggregatesFilter<"Utilisateur"> | string
    email?: StringWithAggregatesFilter<"Utilisateur"> | string
  }

  export type CandidatCreateInput = {
    id_candidat?: string
    numeroInscription: number
    nom: string
    prenoms?: string | null
    date_naissance: Date | string
    sexe: $Enums.SEXE
    isApte: boolean
    choix?: ChoixCreateNestedManyWithoutCandidatInput
  }

  export type CandidatUncheckedCreateInput = {
    id_candidat?: string
    numeroInscription: number
    nom: string
    prenoms?: string | null
    date_naissance: Date | string
    sexe: $Enums.SEXE
    isApte: boolean
    choix?: ChoixUncheckedCreateNestedManyWithoutCandidatInput
  }

  export type CandidatUpdateInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
    choix?: ChoixUpdateManyWithoutCandidatNestedInput
  }

  export type CandidatUncheckedUpdateInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
    choix?: ChoixUncheckedUpdateManyWithoutCandidatNestedInput
  }

  export type CandidatCreateManyInput = {
    id_candidat?: string
    numeroInscription: number
    nom: string
    prenoms?: string | null
    date_naissance: Date | string
    sexe: $Enums.SEXE
    isApte: boolean
  }

  export type CandidatUpdateManyMutationInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CandidatUncheckedUpdateManyInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GroupeCreateInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    examinateur: ExaminateurCreateNestedOneWithoutGroupesInput
    terrain: TerrainCreateNestedOneWithoutGroupesInput
  }

  export type GroupeUncheckedCreateInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    id_examinateur: string
    terrainId: string
  }

  export type GroupeUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    examinateur?: ExaminateurUpdateOneRequiredWithoutGroupesNestedInput
    terrain?: TerrainUpdateOneRequiredWithoutGroupesNestedInput
  }

  export type GroupeUncheckedUpdateInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    id_examinateur?: StringFieldUpdateOperationsInput | string
    terrainId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeCreateManyInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    id_examinateur: string
    terrainId: string
  }

  export type GroupeUpdateManyMutationInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeUncheckedUpdateManyInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    id_examinateur?: StringFieldUpdateOperationsInput | string
    terrainId?: StringFieldUpdateOperationsInput | string
  }

  export type ExaminateurCreateInput = {
    id_examinateur?: string
    nom_examinateur: string
    groupes?: GroupeCreateNestedManyWithoutExaminateurInput
  }

  export type ExaminateurUncheckedCreateInput = {
    id_examinateur?: string
    nom_examinateur: string
    groupes?: GroupeUncheckedCreateNestedManyWithoutExaminateurInput
  }

  export type ExaminateurUpdateInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
    groupes?: GroupeUpdateManyWithoutExaminateurNestedInput
  }

  export type ExaminateurUncheckedUpdateInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
    groupes?: GroupeUncheckedUpdateManyWithoutExaminateurNestedInput
  }

  export type ExaminateurCreateManyInput = {
    id_examinateur?: string
    nom_examinateur: string
  }

  export type ExaminateurUpdateManyMutationInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type ExaminateurUncheckedUpdateManyInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type TerrainCreateInput = {
    id_terrain?: string
    nom_terrain: string
    centre: CentreCreateNestedOneWithoutTerrainsInput
    groupes?: GroupeCreateNestedManyWithoutTerrainInput
  }

  export type TerrainUncheckedCreateInput = {
    id_terrain?: string
    nom_terrain: string
    id_centre: string
    groupes?: GroupeUncheckedCreateNestedManyWithoutTerrainInput
  }

  export type TerrainUpdateInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    centre?: CentreUpdateOneRequiredWithoutTerrainsNestedInput
    groupes?: GroupeUpdateManyWithoutTerrainNestedInput
  }

  export type TerrainUncheckedUpdateInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    id_centre?: StringFieldUpdateOperationsInput | string
    groupes?: GroupeUncheckedUpdateManyWithoutTerrainNestedInput
  }

  export type TerrainCreateManyInput = {
    id_terrain?: string
    nom_terrain: string
    id_centre: string
  }

  export type TerrainUpdateManyMutationInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
  }

  export type TerrainUncheckedUpdateManyInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    id_centre?: StringFieldUpdateOperationsInput | string
  }

  export type CentreCreateInput = {
    id_centre?: string
    lieu: string
    terrains?: TerrainCreateNestedManyWithoutCentreInput
  }

  export type CentreUncheckedCreateInput = {
    id_centre?: string
    lieu: string
    terrains?: TerrainUncheckedCreateNestedManyWithoutCentreInput
  }

  export type CentreUpdateInput = {
    lieu?: StringFieldUpdateOperationsInput | string
    terrains?: TerrainUpdateManyWithoutCentreNestedInput
  }

  export type CentreUncheckedUpdateInput = {
    lieu?: StringFieldUpdateOperationsInput | string
    terrains?: TerrainUncheckedUpdateManyWithoutCentreNestedInput
  }

  export type CentreCreateManyInput = {
    id_centre?: string
    lieu: string
  }

  export type CentreUpdateManyMutationInput = {
    lieu?: StringFieldUpdateOperationsInput | string
  }

  export type CentreUncheckedUpdateManyInput = {
    lieu?: StringFieldUpdateOperationsInput | string
  }

  export type ChoixCreateInput = {
    id_choix?: string
    candidat: CandidatCreateNestedOneWithoutChoixInput
    sport: SportCreateNestedOneWithoutChoixInput
  }

  export type ChoixUncheckedCreateInput = {
    id_choix?: string
    id_candidat: string
    id_sport: string
  }

  export type ChoixUpdateInput = {
    candidat?: CandidatUpdateOneRequiredWithoutChoixNestedInput
    sport?: SportUpdateOneRequiredWithoutChoixNestedInput
  }

  export type ChoixUncheckedUpdateInput = {
    id_candidat?: StringFieldUpdateOperationsInput | string
    id_sport?: StringFieldUpdateOperationsInput | string
  }

  export type ChoixCreateManyInput = {
    id_choix?: string
    id_candidat: string
    id_sport: string
  }

  export type ChoixUpdateManyMutationInput = {

  }

  export type ChoixUncheckedUpdateManyInput = {
    id_candidat?: StringFieldUpdateOperationsInput | string
    id_sport?: StringFieldUpdateOperationsInput | string
  }

  export type SportCreateInput = {
    id_sport?: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
    choix?: ChoixCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateInput = {
    id_sport?: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
    choix?: ChoixUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportUpdateInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
    choix?: ChoixUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
    choix?: ChoixUncheckedUpdateManyWithoutSportNestedInput
  }

  export type SportCreateManyInput = {
    id_sport?: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
  }

  export type SportUpdateManyMutationInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
  }

  export type SportUncheckedUpdateManyInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
  }

  export type UtilisateurCreateInput = {
    id_utilisateur?: string
    nom_complet: string
    password: string
    email: string
  }

  export type UtilisateurUncheckedCreateInput = {
    id_utilisateur?: string
    nom_complet: string
    password: string
    email: string
  }

  export type UtilisateurUpdateInput = {
    nom_complet?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UtilisateurUncheckedUpdateInput = {
    nom_complet?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UtilisateurCreateManyInput = {
    id_utilisateur?: string
    nom_complet: string
    password: string
    email: string
  }

  export type UtilisateurUpdateManyMutationInput = {
    nom_complet?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UtilisateurUncheckedUpdateManyInput = {
    nom_complet?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumSEXEFilter<$PrismaModel = never> = {
    equals?: $Enums.SEXE | EnumSEXEFieldRefInput<$PrismaModel>
    in?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    not?: NestedEnumSEXEFilter<$PrismaModel> | $Enums.SEXE
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ChoixListRelationFilter = {
    every?: ChoixWhereInput
    some?: ChoixWhereInput
    none?: ChoixWhereInput
  }

  export type ChoixOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidatCountOrderByAggregateInput = {
    id_candidat?: SortOrder
    numeroInscription?: SortOrder
    nom?: SortOrder
    prenoms?: SortOrder
    date_naissance?: SortOrder
    sexe?: SortOrder
    isApte?: SortOrder
  }

  export type CandidatAvgOrderByAggregateInput = {
    numeroInscription?: SortOrder
  }

  export type CandidatMaxOrderByAggregateInput = {
    id_candidat?: SortOrder
    numeroInscription?: SortOrder
    nom?: SortOrder
    prenoms?: SortOrder
    date_naissance?: SortOrder
    sexe?: SortOrder
    isApte?: SortOrder
  }

  export type CandidatMinOrderByAggregateInput = {
    id_candidat?: SortOrder
    numeroInscription?: SortOrder
    nom?: SortOrder
    prenoms?: SortOrder
    date_naissance?: SortOrder
    sexe?: SortOrder
    isApte?: SortOrder
  }

  export type CandidatSumOrderByAggregateInput = {
    numeroInscription?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSEXEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEXE | EnumSEXEFieldRefInput<$PrismaModel>
    in?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    not?: NestedEnumSEXEWithAggregatesFilter<$PrismaModel> | $Enums.SEXE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEXEFilter<$PrismaModel>
    _max?: NestedEnumSEXEFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTEMPSFilter<$PrismaModel = never> = {
    equals?: $Enums.TEMPS | EnumTEMPSFieldRefInput<$PrismaModel>
    in?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    notIn?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    not?: NestedEnumTEMPSFilter<$PrismaModel> | $Enums.TEMPS
  }

  export type ExaminateurRelationFilter = {
    is?: ExaminateurWhereInput
    isNot?: ExaminateurWhereInput
  }

  export type TerrainRelationFilter = {
    is?: TerrainWhereInput
    isNot?: TerrainWhereInput
  }

  export type GroupeCountOrderByAggregateInput = {
    id_groupe?: SortOrder
    numero?: SortOrder
    date_epreuve?: SortOrder
    temps?: SortOrder
    heure?: SortOrder
    id_examinateur?: SortOrder
    terrainId?: SortOrder
  }

  export type GroupeAvgOrderByAggregateInput = {
    numero?: SortOrder
  }

  export type GroupeMaxOrderByAggregateInput = {
    id_groupe?: SortOrder
    numero?: SortOrder
    date_epreuve?: SortOrder
    temps?: SortOrder
    heure?: SortOrder
    id_examinateur?: SortOrder
    terrainId?: SortOrder
  }

  export type GroupeMinOrderByAggregateInput = {
    id_groupe?: SortOrder
    numero?: SortOrder
    date_epreuve?: SortOrder
    temps?: SortOrder
    heure?: SortOrder
    id_examinateur?: SortOrder
    terrainId?: SortOrder
  }

  export type GroupeSumOrderByAggregateInput = {
    numero?: SortOrder
  }

  export type EnumTEMPSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TEMPS | EnumTEMPSFieldRefInput<$PrismaModel>
    in?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    notIn?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    not?: NestedEnumTEMPSWithAggregatesFilter<$PrismaModel> | $Enums.TEMPS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTEMPSFilter<$PrismaModel>
    _max?: NestedEnumTEMPSFilter<$PrismaModel>
  }

  export type GroupeListRelationFilter = {
    every?: GroupeWhereInput
    some?: GroupeWhereInput
    none?: GroupeWhereInput
  }

  export type GroupeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExaminateurCountOrderByAggregateInput = {
    id_examinateur?: SortOrder
    nom_examinateur?: SortOrder
  }

  export type ExaminateurMaxOrderByAggregateInput = {
    id_examinateur?: SortOrder
    nom_examinateur?: SortOrder
  }

  export type ExaminateurMinOrderByAggregateInput = {
    id_examinateur?: SortOrder
    nom_examinateur?: SortOrder
  }

  export type CentreRelationFilter = {
    is?: CentreWhereInput
    isNot?: CentreWhereInput
  }

  export type TerrainCountOrderByAggregateInput = {
    id_terrain?: SortOrder
    nom_terrain?: SortOrder
    id_centre?: SortOrder
  }

  export type TerrainMaxOrderByAggregateInput = {
    id_terrain?: SortOrder
    nom_terrain?: SortOrder
    id_centre?: SortOrder
  }

  export type TerrainMinOrderByAggregateInput = {
    id_terrain?: SortOrder
    nom_terrain?: SortOrder
    id_centre?: SortOrder
  }

  export type TerrainListRelationFilter = {
    every?: TerrainWhereInput
    some?: TerrainWhereInput
    none?: TerrainWhereInput
  }

  export type TerrainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CentreCountOrderByAggregateInput = {
    id_centre?: SortOrder
    lieu?: SortOrder
  }

  export type CentreMaxOrderByAggregateInput = {
    id_centre?: SortOrder
    lieu?: SortOrder
  }

  export type CentreMinOrderByAggregateInput = {
    id_centre?: SortOrder
    lieu?: SortOrder
  }

  export type CandidatRelationFilter = {
    is?: CandidatWhereInput
    isNot?: CandidatWhereInput
  }

  export type SportRelationFilter = {
    is?: SportWhereInput
    isNot?: SportWhereInput
  }

  export type ChoixCountOrderByAggregateInput = {
    id_choix?: SortOrder
    id_candidat?: SortOrder
    id_sport?: SortOrder
  }

  export type ChoixMaxOrderByAggregateInput = {
    id_choix?: SortOrder
    id_candidat?: SortOrder
    id_sport?: SortOrder
  }

  export type ChoixMinOrderByAggregateInput = {
    id_choix?: SortOrder
    id_candidat?: SortOrder
    id_sport?: SortOrder
  }

  export type EnumTYPE_SPORTFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPE_SPORT | EnumTYPE_SPORTFieldRefInput<$PrismaModel>
    in?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    notIn?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    not?: NestedEnumTYPE_SPORTFilter<$PrismaModel> | $Enums.TYPE_SPORT
  }

  export type SportCountOrderByAggregateInput = {
    id_sport?: SortOrder
    nom_sport?: SortOrder
    type?: SortOrder
  }

  export type SportMaxOrderByAggregateInput = {
    id_sport?: SortOrder
    nom_sport?: SortOrder
    type?: SortOrder
  }

  export type SportMinOrderByAggregateInput = {
    id_sport?: SortOrder
    nom_sport?: SortOrder
    type?: SortOrder
  }

  export type EnumTYPE_SPORTWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPE_SPORT | EnumTYPE_SPORTFieldRefInput<$PrismaModel>
    in?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    notIn?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    not?: NestedEnumTYPE_SPORTWithAggregatesFilter<$PrismaModel> | $Enums.TYPE_SPORT
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTYPE_SPORTFilter<$PrismaModel>
    _max?: NestedEnumTYPE_SPORTFilter<$PrismaModel>
  }

  export type UtilisateurCountOrderByAggregateInput = {
    id_utilisateur?: SortOrder
    nom_complet?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type UtilisateurMaxOrderByAggregateInput = {
    id_utilisateur?: SortOrder
    nom_complet?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type UtilisateurMinOrderByAggregateInput = {
    id_utilisateur?: SortOrder
    nom_complet?: SortOrder
    password?: SortOrder
    email?: SortOrder
  }

  export type ChoixCreateNestedManyWithoutCandidatInput = {
    create?: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput> | ChoixCreateWithoutCandidatInput[] | ChoixUncheckedCreateWithoutCandidatInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutCandidatInput | ChoixCreateOrConnectWithoutCandidatInput[]
    createMany?: ChoixCreateManyCandidatInputEnvelope
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
  }

  export type ChoixUncheckedCreateNestedManyWithoutCandidatInput = {
    create?: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput> | ChoixCreateWithoutCandidatInput[] | ChoixUncheckedCreateWithoutCandidatInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutCandidatInput | ChoixCreateOrConnectWithoutCandidatInput[]
    createMany?: ChoixCreateManyCandidatInputEnvelope
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumSEXEFieldUpdateOperationsInput = {
    set?: $Enums.SEXE
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ChoixUpdateManyWithoutCandidatNestedInput = {
    create?: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput> | ChoixCreateWithoutCandidatInput[] | ChoixUncheckedCreateWithoutCandidatInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutCandidatInput | ChoixCreateOrConnectWithoutCandidatInput[]
    upsert?: ChoixUpsertWithWhereUniqueWithoutCandidatInput | ChoixUpsertWithWhereUniqueWithoutCandidatInput[]
    createMany?: ChoixCreateManyCandidatInputEnvelope
    set?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    disconnect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    delete?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    update?: ChoixUpdateWithWhereUniqueWithoutCandidatInput | ChoixUpdateWithWhereUniqueWithoutCandidatInput[]
    updateMany?: ChoixUpdateManyWithWhereWithoutCandidatInput | ChoixUpdateManyWithWhereWithoutCandidatInput[]
    deleteMany?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
  }

  export type ChoixUncheckedUpdateManyWithoutCandidatNestedInput = {
    create?: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput> | ChoixCreateWithoutCandidatInput[] | ChoixUncheckedCreateWithoutCandidatInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutCandidatInput | ChoixCreateOrConnectWithoutCandidatInput[]
    upsert?: ChoixUpsertWithWhereUniqueWithoutCandidatInput | ChoixUpsertWithWhereUniqueWithoutCandidatInput[]
    createMany?: ChoixCreateManyCandidatInputEnvelope
    set?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    disconnect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    delete?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    update?: ChoixUpdateWithWhereUniqueWithoutCandidatInput | ChoixUpdateWithWhereUniqueWithoutCandidatInput[]
    updateMany?: ChoixUpdateManyWithWhereWithoutCandidatInput | ChoixUpdateManyWithWhereWithoutCandidatInput[]
    deleteMany?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
  }

  export type ExaminateurCreateNestedOneWithoutGroupesInput = {
    create?: XOR<ExaminateurCreateWithoutGroupesInput, ExaminateurUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: ExaminateurCreateOrConnectWithoutGroupesInput
    connect?: ExaminateurWhereUniqueInput
  }

  export type TerrainCreateNestedOneWithoutGroupesInput = {
    create?: XOR<TerrainCreateWithoutGroupesInput, TerrainUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: TerrainCreateOrConnectWithoutGroupesInput
    connect?: TerrainWhereUniqueInput
  }

  export type EnumTEMPSFieldUpdateOperationsInput = {
    set?: $Enums.TEMPS
  }

  export type ExaminateurUpdateOneRequiredWithoutGroupesNestedInput = {
    create?: XOR<ExaminateurCreateWithoutGroupesInput, ExaminateurUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: ExaminateurCreateOrConnectWithoutGroupesInput
    upsert?: ExaminateurUpsertWithoutGroupesInput
    connect?: ExaminateurWhereUniqueInput
    update?: XOR<XOR<ExaminateurUpdateToOneWithWhereWithoutGroupesInput, ExaminateurUpdateWithoutGroupesInput>, ExaminateurUncheckedUpdateWithoutGroupesInput>
  }

  export type TerrainUpdateOneRequiredWithoutGroupesNestedInput = {
    create?: XOR<TerrainCreateWithoutGroupesInput, TerrainUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: TerrainCreateOrConnectWithoutGroupesInput
    upsert?: TerrainUpsertWithoutGroupesInput
    connect?: TerrainWhereUniqueInput
    update?: XOR<XOR<TerrainUpdateToOneWithWhereWithoutGroupesInput, TerrainUpdateWithoutGroupesInput>, TerrainUncheckedUpdateWithoutGroupesInput>
  }

  export type GroupeCreateNestedManyWithoutExaminateurInput = {
    create?: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput> | GroupeCreateWithoutExaminateurInput[] | GroupeUncheckedCreateWithoutExaminateurInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutExaminateurInput | GroupeCreateOrConnectWithoutExaminateurInput[]
    createMany?: GroupeCreateManyExaminateurInputEnvelope
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
  }

  export type GroupeUncheckedCreateNestedManyWithoutExaminateurInput = {
    create?: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput> | GroupeCreateWithoutExaminateurInput[] | GroupeUncheckedCreateWithoutExaminateurInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutExaminateurInput | GroupeCreateOrConnectWithoutExaminateurInput[]
    createMany?: GroupeCreateManyExaminateurInputEnvelope
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
  }

  export type GroupeUpdateManyWithoutExaminateurNestedInput = {
    create?: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput> | GroupeCreateWithoutExaminateurInput[] | GroupeUncheckedCreateWithoutExaminateurInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutExaminateurInput | GroupeCreateOrConnectWithoutExaminateurInput[]
    upsert?: GroupeUpsertWithWhereUniqueWithoutExaminateurInput | GroupeUpsertWithWhereUniqueWithoutExaminateurInput[]
    createMany?: GroupeCreateManyExaminateurInputEnvelope
    set?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    disconnect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    delete?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    update?: GroupeUpdateWithWhereUniqueWithoutExaminateurInput | GroupeUpdateWithWhereUniqueWithoutExaminateurInput[]
    updateMany?: GroupeUpdateManyWithWhereWithoutExaminateurInput | GroupeUpdateManyWithWhereWithoutExaminateurInput[]
    deleteMany?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
  }

  export type GroupeUncheckedUpdateManyWithoutExaminateurNestedInput = {
    create?: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput> | GroupeCreateWithoutExaminateurInput[] | GroupeUncheckedCreateWithoutExaminateurInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutExaminateurInput | GroupeCreateOrConnectWithoutExaminateurInput[]
    upsert?: GroupeUpsertWithWhereUniqueWithoutExaminateurInput | GroupeUpsertWithWhereUniqueWithoutExaminateurInput[]
    createMany?: GroupeCreateManyExaminateurInputEnvelope
    set?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    disconnect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    delete?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    update?: GroupeUpdateWithWhereUniqueWithoutExaminateurInput | GroupeUpdateWithWhereUniqueWithoutExaminateurInput[]
    updateMany?: GroupeUpdateManyWithWhereWithoutExaminateurInput | GroupeUpdateManyWithWhereWithoutExaminateurInput[]
    deleteMany?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
  }

  export type CentreCreateNestedOneWithoutTerrainsInput = {
    create?: XOR<CentreCreateWithoutTerrainsInput, CentreUncheckedCreateWithoutTerrainsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutTerrainsInput
    connect?: CentreWhereUniqueInput
  }

  export type GroupeCreateNestedManyWithoutTerrainInput = {
    create?: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput> | GroupeCreateWithoutTerrainInput[] | GroupeUncheckedCreateWithoutTerrainInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutTerrainInput | GroupeCreateOrConnectWithoutTerrainInput[]
    createMany?: GroupeCreateManyTerrainInputEnvelope
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
  }

  export type GroupeUncheckedCreateNestedManyWithoutTerrainInput = {
    create?: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput> | GroupeCreateWithoutTerrainInput[] | GroupeUncheckedCreateWithoutTerrainInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutTerrainInput | GroupeCreateOrConnectWithoutTerrainInput[]
    createMany?: GroupeCreateManyTerrainInputEnvelope
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
  }

  export type CentreUpdateOneRequiredWithoutTerrainsNestedInput = {
    create?: XOR<CentreCreateWithoutTerrainsInput, CentreUncheckedCreateWithoutTerrainsInput>
    connectOrCreate?: CentreCreateOrConnectWithoutTerrainsInput
    upsert?: CentreUpsertWithoutTerrainsInput
    connect?: CentreWhereUniqueInput
    update?: XOR<XOR<CentreUpdateToOneWithWhereWithoutTerrainsInput, CentreUpdateWithoutTerrainsInput>, CentreUncheckedUpdateWithoutTerrainsInput>
  }

  export type GroupeUpdateManyWithoutTerrainNestedInput = {
    create?: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput> | GroupeCreateWithoutTerrainInput[] | GroupeUncheckedCreateWithoutTerrainInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutTerrainInput | GroupeCreateOrConnectWithoutTerrainInput[]
    upsert?: GroupeUpsertWithWhereUniqueWithoutTerrainInput | GroupeUpsertWithWhereUniqueWithoutTerrainInput[]
    createMany?: GroupeCreateManyTerrainInputEnvelope
    set?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    disconnect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    delete?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    update?: GroupeUpdateWithWhereUniqueWithoutTerrainInput | GroupeUpdateWithWhereUniqueWithoutTerrainInput[]
    updateMany?: GroupeUpdateManyWithWhereWithoutTerrainInput | GroupeUpdateManyWithWhereWithoutTerrainInput[]
    deleteMany?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
  }

  export type GroupeUncheckedUpdateManyWithoutTerrainNestedInput = {
    create?: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput> | GroupeCreateWithoutTerrainInput[] | GroupeUncheckedCreateWithoutTerrainInput[]
    connectOrCreate?: GroupeCreateOrConnectWithoutTerrainInput | GroupeCreateOrConnectWithoutTerrainInput[]
    upsert?: GroupeUpsertWithWhereUniqueWithoutTerrainInput | GroupeUpsertWithWhereUniqueWithoutTerrainInput[]
    createMany?: GroupeCreateManyTerrainInputEnvelope
    set?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    disconnect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    delete?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    connect?: GroupeWhereUniqueInput | GroupeWhereUniqueInput[]
    update?: GroupeUpdateWithWhereUniqueWithoutTerrainInput | GroupeUpdateWithWhereUniqueWithoutTerrainInput[]
    updateMany?: GroupeUpdateManyWithWhereWithoutTerrainInput | GroupeUpdateManyWithWhereWithoutTerrainInput[]
    deleteMany?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
  }

  export type TerrainCreateNestedManyWithoutCentreInput = {
    create?: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput> | TerrainCreateWithoutCentreInput[] | TerrainUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: TerrainCreateOrConnectWithoutCentreInput | TerrainCreateOrConnectWithoutCentreInput[]
    createMany?: TerrainCreateManyCentreInputEnvelope
    connect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
  }

  export type TerrainUncheckedCreateNestedManyWithoutCentreInput = {
    create?: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput> | TerrainCreateWithoutCentreInput[] | TerrainUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: TerrainCreateOrConnectWithoutCentreInput | TerrainCreateOrConnectWithoutCentreInput[]
    createMany?: TerrainCreateManyCentreInputEnvelope
    connect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
  }

  export type TerrainUpdateManyWithoutCentreNestedInput = {
    create?: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput> | TerrainCreateWithoutCentreInput[] | TerrainUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: TerrainCreateOrConnectWithoutCentreInput | TerrainCreateOrConnectWithoutCentreInput[]
    upsert?: TerrainUpsertWithWhereUniqueWithoutCentreInput | TerrainUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: TerrainCreateManyCentreInputEnvelope
    set?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    disconnect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    delete?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    connect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    update?: TerrainUpdateWithWhereUniqueWithoutCentreInput | TerrainUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: TerrainUpdateManyWithWhereWithoutCentreInput | TerrainUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: TerrainScalarWhereInput | TerrainScalarWhereInput[]
  }

  export type TerrainUncheckedUpdateManyWithoutCentreNestedInput = {
    create?: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput> | TerrainCreateWithoutCentreInput[] | TerrainUncheckedCreateWithoutCentreInput[]
    connectOrCreate?: TerrainCreateOrConnectWithoutCentreInput | TerrainCreateOrConnectWithoutCentreInput[]
    upsert?: TerrainUpsertWithWhereUniqueWithoutCentreInput | TerrainUpsertWithWhereUniqueWithoutCentreInput[]
    createMany?: TerrainCreateManyCentreInputEnvelope
    set?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    disconnect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    delete?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    connect?: TerrainWhereUniqueInput | TerrainWhereUniqueInput[]
    update?: TerrainUpdateWithWhereUniqueWithoutCentreInput | TerrainUpdateWithWhereUniqueWithoutCentreInput[]
    updateMany?: TerrainUpdateManyWithWhereWithoutCentreInput | TerrainUpdateManyWithWhereWithoutCentreInput[]
    deleteMany?: TerrainScalarWhereInput | TerrainScalarWhereInput[]
  }

  export type CandidatCreateNestedOneWithoutChoixInput = {
    create?: XOR<CandidatCreateWithoutChoixInput, CandidatUncheckedCreateWithoutChoixInput>
    connectOrCreate?: CandidatCreateOrConnectWithoutChoixInput
    connect?: CandidatWhereUniqueInput
  }

  export type SportCreateNestedOneWithoutChoixInput = {
    create?: XOR<SportCreateWithoutChoixInput, SportUncheckedCreateWithoutChoixInput>
    connectOrCreate?: SportCreateOrConnectWithoutChoixInput
    connect?: SportWhereUniqueInput
  }

  export type CandidatUpdateOneRequiredWithoutChoixNestedInput = {
    create?: XOR<CandidatCreateWithoutChoixInput, CandidatUncheckedCreateWithoutChoixInput>
    connectOrCreate?: CandidatCreateOrConnectWithoutChoixInput
    upsert?: CandidatUpsertWithoutChoixInput
    connect?: CandidatWhereUniqueInput
    update?: XOR<XOR<CandidatUpdateToOneWithWhereWithoutChoixInput, CandidatUpdateWithoutChoixInput>, CandidatUncheckedUpdateWithoutChoixInput>
  }

  export type SportUpdateOneRequiredWithoutChoixNestedInput = {
    create?: XOR<SportCreateWithoutChoixInput, SportUncheckedCreateWithoutChoixInput>
    connectOrCreate?: SportCreateOrConnectWithoutChoixInput
    upsert?: SportUpsertWithoutChoixInput
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutChoixInput, SportUpdateWithoutChoixInput>, SportUncheckedUpdateWithoutChoixInput>
  }

  export type ChoixCreateNestedManyWithoutSportInput = {
    create?: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput> | ChoixCreateWithoutSportInput[] | ChoixUncheckedCreateWithoutSportInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutSportInput | ChoixCreateOrConnectWithoutSportInput[]
    createMany?: ChoixCreateManySportInputEnvelope
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
  }

  export type ChoixUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput> | ChoixCreateWithoutSportInput[] | ChoixUncheckedCreateWithoutSportInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutSportInput | ChoixCreateOrConnectWithoutSportInput[]
    createMany?: ChoixCreateManySportInputEnvelope
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
  }

  export type EnumTYPE_SPORTFieldUpdateOperationsInput = {
    set?: $Enums.TYPE_SPORT
  }

  export type ChoixUpdateManyWithoutSportNestedInput = {
    create?: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput> | ChoixCreateWithoutSportInput[] | ChoixUncheckedCreateWithoutSportInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutSportInput | ChoixCreateOrConnectWithoutSportInput[]
    upsert?: ChoixUpsertWithWhereUniqueWithoutSportInput | ChoixUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: ChoixCreateManySportInputEnvelope
    set?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    disconnect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    delete?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    update?: ChoixUpdateWithWhereUniqueWithoutSportInput | ChoixUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: ChoixUpdateManyWithWhereWithoutSportInput | ChoixUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
  }

  export type ChoixUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput> | ChoixCreateWithoutSportInput[] | ChoixUncheckedCreateWithoutSportInput[]
    connectOrCreate?: ChoixCreateOrConnectWithoutSportInput | ChoixCreateOrConnectWithoutSportInput[]
    upsert?: ChoixUpsertWithWhereUniqueWithoutSportInput | ChoixUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: ChoixCreateManySportInputEnvelope
    set?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    disconnect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    delete?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    connect?: ChoixWhereUniqueInput | ChoixWhereUniqueInput[]
    update?: ChoixUpdateWithWhereUniqueWithoutSportInput | ChoixUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: ChoixUpdateManyWithWhereWithoutSportInput | ChoixUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSEXEFilter<$PrismaModel = never> = {
    equals?: $Enums.SEXE | EnumSEXEFieldRefInput<$PrismaModel>
    in?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    not?: NestedEnumSEXEFilter<$PrismaModel> | $Enums.SEXE
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSEXEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SEXE | EnumSEXEFieldRefInput<$PrismaModel>
    in?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    notIn?: $Enums.SEXE[] | ListEnumSEXEFieldRefInput<$PrismaModel>
    not?: NestedEnumSEXEWithAggregatesFilter<$PrismaModel> | $Enums.SEXE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSEXEFilter<$PrismaModel>
    _max?: NestedEnumSEXEFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTEMPSFilter<$PrismaModel = never> = {
    equals?: $Enums.TEMPS | EnumTEMPSFieldRefInput<$PrismaModel>
    in?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    notIn?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    not?: NestedEnumTEMPSFilter<$PrismaModel> | $Enums.TEMPS
  }

  export type NestedEnumTEMPSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TEMPS | EnumTEMPSFieldRefInput<$PrismaModel>
    in?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    notIn?: $Enums.TEMPS[] | ListEnumTEMPSFieldRefInput<$PrismaModel>
    not?: NestedEnumTEMPSWithAggregatesFilter<$PrismaModel> | $Enums.TEMPS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTEMPSFilter<$PrismaModel>
    _max?: NestedEnumTEMPSFilter<$PrismaModel>
  }

  export type NestedEnumTYPE_SPORTFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPE_SPORT | EnumTYPE_SPORTFieldRefInput<$PrismaModel>
    in?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    notIn?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    not?: NestedEnumTYPE_SPORTFilter<$PrismaModel> | $Enums.TYPE_SPORT
  }

  export type NestedEnumTYPE_SPORTWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TYPE_SPORT | EnumTYPE_SPORTFieldRefInput<$PrismaModel>
    in?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    notIn?: $Enums.TYPE_SPORT[] | ListEnumTYPE_SPORTFieldRefInput<$PrismaModel>
    not?: NestedEnumTYPE_SPORTWithAggregatesFilter<$PrismaModel> | $Enums.TYPE_SPORT
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTYPE_SPORTFilter<$PrismaModel>
    _max?: NestedEnumTYPE_SPORTFilter<$PrismaModel>
  }

  export type ChoixCreateWithoutCandidatInput = {
    id_choix?: string
    sport: SportCreateNestedOneWithoutChoixInput
  }

  export type ChoixUncheckedCreateWithoutCandidatInput = {
    id_choix?: string
    id_sport: string
  }

  export type ChoixCreateOrConnectWithoutCandidatInput = {
    where: ChoixWhereUniqueInput
    create: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput>
  }

  export type ChoixCreateManyCandidatInputEnvelope = {
    data: ChoixCreateManyCandidatInput | ChoixCreateManyCandidatInput[]
  }

  export type ChoixUpsertWithWhereUniqueWithoutCandidatInput = {
    where: ChoixWhereUniqueInput
    update: XOR<ChoixUpdateWithoutCandidatInput, ChoixUncheckedUpdateWithoutCandidatInput>
    create: XOR<ChoixCreateWithoutCandidatInput, ChoixUncheckedCreateWithoutCandidatInput>
  }

  export type ChoixUpdateWithWhereUniqueWithoutCandidatInput = {
    where: ChoixWhereUniqueInput
    data: XOR<ChoixUpdateWithoutCandidatInput, ChoixUncheckedUpdateWithoutCandidatInput>
  }

  export type ChoixUpdateManyWithWhereWithoutCandidatInput = {
    where: ChoixScalarWhereInput
    data: XOR<ChoixUpdateManyMutationInput, ChoixUncheckedUpdateManyWithoutCandidatInput>
  }

  export type ChoixScalarWhereInput = {
    AND?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
    OR?: ChoixScalarWhereInput[]
    NOT?: ChoixScalarWhereInput | ChoixScalarWhereInput[]
    id_choix?: StringFilter<"Choix"> | string
    id_candidat?: StringFilter<"Choix"> | string
    id_sport?: StringFilter<"Choix"> | string
  }

  export type ExaminateurCreateWithoutGroupesInput = {
    id_examinateur?: string
    nom_examinateur: string
  }

  export type ExaminateurUncheckedCreateWithoutGroupesInput = {
    id_examinateur?: string
    nom_examinateur: string
  }

  export type ExaminateurCreateOrConnectWithoutGroupesInput = {
    where: ExaminateurWhereUniqueInput
    create: XOR<ExaminateurCreateWithoutGroupesInput, ExaminateurUncheckedCreateWithoutGroupesInput>
  }

  export type TerrainCreateWithoutGroupesInput = {
    id_terrain?: string
    nom_terrain: string
    centre: CentreCreateNestedOneWithoutTerrainsInput
  }

  export type TerrainUncheckedCreateWithoutGroupesInput = {
    id_terrain?: string
    nom_terrain: string
    id_centre: string
  }

  export type TerrainCreateOrConnectWithoutGroupesInput = {
    where: TerrainWhereUniqueInput
    create: XOR<TerrainCreateWithoutGroupesInput, TerrainUncheckedCreateWithoutGroupesInput>
  }

  export type ExaminateurUpsertWithoutGroupesInput = {
    update: XOR<ExaminateurUpdateWithoutGroupesInput, ExaminateurUncheckedUpdateWithoutGroupesInput>
    create: XOR<ExaminateurCreateWithoutGroupesInput, ExaminateurUncheckedCreateWithoutGroupesInput>
    where?: ExaminateurWhereInput
  }

  export type ExaminateurUpdateToOneWithWhereWithoutGroupesInput = {
    where?: ExaminateurWhereInput
    data: XOR<ExaminateurUpdateWithoutGroupesInput, ExaminateurUncheckedUpdateWithoutGroupesInput>
  }

  export type ExaminateurUpdateWithoutGroupesInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type ExaminateurUncheckedUpdateWithoutGroupesInput = {
    nom_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type TerrainUpsertWithoutGroupesInput = {
    update: XOR<TerrainUpdateWithoutGroupesInput, TerrainUncheckedUpdateWithoutGroupesInput>
    create: XOR<TerrainCreateWithoutGroupesInput, TerrainUncheckedCreateWithoutGroupesInput>
    where?: TerrainWhereInput
  }

  export type TerrainUpdateToOneWithWhereWithoutGroupesInput = {
    where?: TerrainWhereInput
    data: XOR<TerrainUpdateWithoutGroupesInput, TerrainUncheckedUpdateWithoutGroupesInput>
  }

  export type TerrainUpdateWithoutGroupesInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    centre?: CentreUpdateOneRequiredWithoutTerrainsNestedInput
  }

  export type TerrainUncheckedUpdateWithoutGroupesInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    id_centre?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeCreateWithoutExaminateurInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    terrain: TerrainCreateNestedOneWithoutGroupesInput
  }

  export type GroupeUncheckedCreateWithoutExaminateurInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    terrainId: string
  }

  export type GroupeCreateOrConnectWithoutExaminateurInput = {
    where: GroupeWhereUniqueInput
    create: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput>
  }

  export type GroupeCreateManyExaminateurInputEnvelope = {
    data: GroupeCreateManyExaminateurInput | GroupeCreateManyExaminateurInput[]
  }

  export type GroupeUpsertWithWhereUniqueWithoutExaminateurInput = {
    where: GroupeWhereUniqueInput
    update: XOR<GroupeUpdateWithoutExaminateurInput, GroupeUncheckedUpdateWithoutExaminateurInput>
    create: XOR<GroupeCreateWithoutExaminateurInput, GroupeUncheckedCreateWithoutExaminateurInput>
  }

  export type GroupeUpdateWithWhereUniqueWithoutExaminateurInput = {
    where: GroupeWhereUniqueInput
    data: XOR<GroupeUpdateWithoutExaminateurInput, GroupeUncheckedUpdateWithoutExaminateurInput>
  }

  export type GroupeUpdateManyWithWhereWithoutExaminateurInput = {
    where: GroupeScalarWhereInput
    data: XOR<GroupeUpdateManyMutationInput, GroupeUncheckedUpdateManyWithoutExaminateurInput>
  }

  export type GroupeScalarWhereInput = {
    AND?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
    OR?: GroupeScalarWhereInput[]
    NOT?: GroupeScalarWhereInput | GroupeScalarWhereInput[]
    id_groupe?: StringFilter<"Groupe"> | string
    numero?: IntFilter<"Groupe"> | number
    date_epreuve?: DateTimeFilter<"Groupe"> | Date | string
    temps?: EnumTEMPSFilter<"Groupe"> | $Enums.TEMPS
    heure?: StringFilter<"Groupe"> | string
    id_examinateur?: StringFilter<"Groupe"> | string
    terrainId?: StringFilter<"Groupe"> | string
  }

  export type CentreCreateWithoutTerrainsInput = {
    id_centre?: string
    lieu: string
  }

  export type CentreUncheckedCreateWithoutTerrainsInput = {
    id_centre?: string
    lieu: string
  }

  export type CentreCreateOrConnectWithoutTerrainsInput = {
    where: CentreWhereUniqueInput
    create: XOR<CentreCreateWithoutTerrainsInput, CentreUncheckedCreateWithoutTerrainsInput>
  }

  export type GroupeCreateWithoutTerrainInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    examinateur: ExaminateurCreateNestedOneWithoutGroupesInput
  }

  export type GroupeUncheckedCreateWithoutTerrainInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    id_examinateur: string
  }

  export type GroupeCreateOrConnectWithoutTerrainInput = {
    where: GroupeWhereUniqueInput
    create: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput>
  }

  export type GroupeCreateManyTerrainInputEnvelope = {
    data: GroupeCreateManyTerrainInput | GroupeCreateManyTerrainInput[]
  }

  export type CentreUpsertWithoutTerrainsInput = {
    update: XOR<CentreUpdateWithoutTerrainsInput, CentreUncheckedUpdateWithoutTerrainsInput>
    create: XOR<CentreCreateWithoutTerrainsInput, CentreUncheckedCreateWithoutTerrainsInput>
    where?: CentreWhereInput
  }

  export type CentreUpdateToOneWithWhereWithoutTerrainsInput = {
    where?: CentreWhereInput
    data: XOR<CentreUpdateWithoutTerrainsInput, CentreUncheckedUpdateWithoutTerrainsInput>
  }

  export type CentreUpdateWithoutTerrainsInput = {
    lieu?: StringFieldUpdateOperationsInput | string
  }

  export type CentreUncheckedUpdateWithoutTerrainsInput = {
    lieu?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeUpsertWithWhereUniqueWithoutTerrainInput = {
    where: GroupeWhereUniqueInput
    update: XOR<GroupeUpdateWithoutTerrainInput, GroupeUncheckedUpdateWithoutTerrainInput>
    create: XOR<GroupeCreateWithoutTerrainInput, GroupeUncheckedCreateWithoutTerrainInput>
  }

  export type GroupeUpdateWithWhereUniqueWithoutTerrainInput = {
    where: GroupeWhereUniqueInput
    data: XOR<GroupeUpdateWithoutTerrainInput, GroupeUncheckedUpdateWithoutTerrainInput>
  }

  export type GroupeUpdateManyWithWhereWithoutTerrainInput = {
    where: GroupeScalarWhereInput
    data: XOR<GroupeUpdateManyMutationInput, GroupeUncheckedUpdateManyWithoutTerrainInput>
  }

  export type TerrainCreateWithoutCentreInput = {
    id_terrain?: string
    nom_terrain: string
    groupes?: GroupeCreateNestedManyWithoutTerrainInput
  }

  export type TerrainUncheckedCreateWithoutCentreInput = {
    id_terrain?: string
    nom_terrain: string
    groupes?: GroupeUncheckedCreateNestedManyWithoutTerrainInput
  }

  export type TerrainCreateOrConnectWithoutCentreInput = {
    where: TerrainWhereUniqueInput
    create: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput>
  }

  export type TerrainCreateManyCentreInputEnvelope = {
    data: TerrainCreateManyCentreInput | TerrainCreateManyCentreInput[]
  }

  export type TerrainUpsertWithWhereUniqueWithoutCentreInput = {
    where: TerrainWhereUniqueInput
    update: XOR<TerrainUpdateWithoutCentreInput, TerrainUncheckedUpdateWithoutCentreInput>
    create: XOR<TerrainCreateWithoutCentreInput, TerrainUncheckedCreateWithoutCentreInput>
  }

  export type TerrainUpdateWithWhereUniqueWithoutCentreInput = {
    where: TerrainWhereUniqueInput
    data: XOR<TerrainUpdateWithoutCentreInput, TerrainUncheckedUpdateWithoutCentreInput>
  }

  export type TerrainUpdateManyWithWhereWithoutCentreInput = {
    where: TerrainScalarWhereInput
    data: XOR<TerrainUpdateManyMutationInput, TerrainUncheckedUpdateManyWithoutCentreInput>
  }

  export type TerrainScalarWhereInput = {
    AND?: TerrainScalarWhereInput | TerrainScalarWhereInput[]
    OR?: TerrainScalarWhereInput[]
    NOT?: TerrainScalarWhereInput | TerrainScalarWhereInput[]
    id_terrain?: StringFilter<"Terrain"> | string
    nom_terrain?: StringFilter<"Terrain"> | string
    id_centre?: StringFilter<"Terrain"> | string
  }

  export type CandidatCreateWithoutChoixInput = {
    id_candidat?: string
    numeroInscription: number
    nom: string
    prenoms?: string | null
    date_naissance: Date | string
    sexe: $Enums.SEXE
    isApte: boolean
  }

  export type CandidatUncheckedCreateWithoutChoixInput = {
    id_candidat?: string
    numeroInscription: number
    nom: string
    prenoms?: string | null
    date_naissance: Date | string
    sexe: $Enums.SEXE
    isApte: boolean
  }

  export type CandidatCreateOrConnectWithoutChoixInput = {
    where: CandidatWhereUniqueInput
    create: XOR<CandidatCreateWithoutChoixInput, CandidatUncheckedCreateWithoutChoixInput>
  }

  export type SportCreateWithoutChoixInput = {
    id_sport?: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
  }

  export type SportUncheckedCreateWithoutChoixInput = {
    id_sport?: string
    nom_sport: string
    type: $Enums.TYPE_SPORT
  }

  export type SportCreateOrConnectWithoutChoixInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutChoixInput, SportUncheckedCreateWithoutChoixInput>
  }

  export type CandidatUpsertWithoutChoixInput = {
    update: XOR<CandidatUpdateWithoutChoixInput, CandidatUncheckedUpdateWithoutChoixInput>
    create: XOR<CandidatCreateWithoutChoixInput, CandidatUncheckedCreateWithoutChoixInput>
    where?: CandidatWhereInput
  }

  export type CandidatUpdateToOneWithWhereWithoutChoixInput = {
    where?: CandidatWhereInput
    data: XOR<CandidatUpdateWithoutChoixInput, CandidatUncheckedUpdateWithoutChoixInput>
  }

  export type CandidatUpdateWithoutChoixInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CandidatUncheckedUpdateWithoutChoixInput = {
    numeroInscription?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenoms?: NullableStringFieldUpdateOperationsInput | string | null
    date_naissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: EnumSEXEFieldUpdateOperationsInput | $Enums.SEXE
    isApte?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SportUpsertWithoutChoixInput = {
    update: XOR<SportUpdateWithoutChoixInput, SportUncheckedUpdateWithoutChoixInput>
    create: XOR<SportCreateWithoutChoixInput, SportUncheckedCreateWithoutChoixInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutChoixInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutChoixInput, SportUncheckedUpdateWithoutChoixInput>
  }

  export type SportUpdateWithoutChoixInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
  }

  export type SportUncheckedUpdateWithoutChoixInput = {
    nom_sport?: StringFieldUpdateOperationsInput | string
    type?: EnumTYPE_SPORTFieldUpdateOperationsInput | $Enums.TYPE_SPORT
  }

  export type ChoixCreateWithoutSportInput = {
    id_choix?: string
    candidat: CandidatCreateNestedOneWithoutChoixInput
  }

  export type ChoixUncheckedCreateWithoutSportInput = {
    id_choix?: string
    id_candidat: string
  }

  export type ChoixCreateOrConnectWithoutSportInput = {
    where: ChoixWhereUniqueInput
    create: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput>
  }

  export type ChoixCreateManySportInputEnvelope = {
    data: ChoixCreateManySportInput | ChoixCreateManySportInput[]
  }

  export type ChoixUpsertWithWhereUniqueWithoutSportInput = {
    where: ChoixWhereUniqueInput
    update: XOR<ChoixUpdateWithoutSportInput, ChoixUncheckedUpdateWithoutSportInput>
    create: XOR<ChoixCreateWithoutSportInput, ChoixUncheckedCreateWithoutSportInput>
  }

  export type ChoixUpdateWithWhereUniqueWithoutSportInput = {
    where: ChoixWhereUniqueInput
    data: XOR<ChoixUpdateWithoutSportInput, ChoixUncheckedUpdateWithoutSportInput>
  }

  export type ChoixUpdateManyWithWhereWithoutSportInput = {
    where: ChoixScalarWhereInput
    data: XOR<ChoixUpdateManyMutationInput, ChoixUncheckedUpdateManyWithoutSportInput>
  }

  export type ChoixCreateManyCandidatInput = {
    id_choix?: string
    id_sport: string
  }

  export type ChoixUpdateWithoutCandidatInput = {
    sport?: SportUpdateOneRequiredWithoutChoixNestedInput
  }

  export type ChoixUncheckedUpdateWithoutCandidatInput = {
    id_sport?: StringFieldUpdateOperationsInput | string
  }

  export type ChoixUncheckedUpdateManyWithoutCandidatInput = {
    id_sport?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeCreateManyExaminateurInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    terrainId: string
  }

  export type GroupeUpdateWithoutExaminateurInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    terrain?: TerrainUpdateOneRequiredWithoutGroupesNestedInput
  }

  export type GroupeUncheckedUpdateWithoutExaminateurInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    terrainId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeUncheckedUpdateManyWithoutExaminateurInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    terrainId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeCreateManyTerrainInput = {
    id_groupe?: string
    numero: number
    date_epreuve: Date | string
    temps: $Enums.TEMPS
    heure: string
    id_examinateur: string
  }

  export type GroupeUpdateWithoutTerrainInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    examinateur?: ExaminateurUpdateOneRequiredWithoutGroupesNestedInput
  }

  export type GroupeUncheckedUpdateWithoutTerrainInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    id_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeUncheckedUpdateManyWithoutTerrainInput = {
    numero?: IntFieldUpdateOperationsInput | number
    date_epreuve?: DateTimeFieldUpdateOperationsInput | Date | string
    temps?: EnumTEMPSFieldUpdateOperationsInput | $Enums.TEMPS
    heure?: StringFieldUpdateOperationsInput | string
    id_examinateur?: StringFieldUpdateOperationsInput | string
  }

  export type TerrainCreateManyCentreInput = {
    id_terrain?: string
    nom_terrain: string
  }

  export type TerrainUpdateWithoutCentreInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    groupes?: GroupeUpdateManyWithoutTerrainNestedInput
  }

  export type TerrainUncheckedUpdateWithoutCentreInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
    groupes?: GroupeUncheckedUpdateManyWithoutTerrainNestedInput
  }

  export type TerrainUncheckedUpdateManyWithoutCentreInput = {
    nom_terrain?: StringFieldUpdateOperationsInput | string
  }

  export type ChoixCreateManySportInput = {
    id_choix?: string
    id_candidat: string
  }

  export type ChoixUpdateWithoutSportInput = {
    candidat?: CandidatUpdateOneRequiredWithoutChoixNestedInput
  }

  export type ChoixUncheckedUpdateWithoutSportInput = {
    id_candidat?: StringFieldUpdateOperationsInput | string
  }

  export type ChoixUncheckedUpdateManyWithoutSportInput = {
    id_candidat?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CandidatCountOutputTypeDefaultArgs instead
     */
    export type CandidatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExaminateurCountOutputTypeDefaultArgs instead
     */
    export type ExaminateurCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExaminateurCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerrainCountOutputTypeDefaultArgs instead
     */
    export type TerrainCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerrainCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CentreCountOutputTypeDefaultArgs instead
     */
    export type CentreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CentreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SportCountOutputTypeDefaultArgs instead
     */
    export type SportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidatDefaultArgs instead
     */
    export type CandidatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupeDefaultArgs instead
     */
    export type GroupeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExaminateurDefaultArgs instead
     */
    export type ExaminateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExaminateurDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerrainDefaultArgs instead
     */
    export type TerrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerrainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CentreDefaultArgs instead
     */
    export type CentreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CentreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoixDefaultArgs instead
     */
    export type ChoixArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoixDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SportDefaultArgs instead
     */
    export type SportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UtilisateurDefaultArgs instead
     */
    export type UtilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtilisateurDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}